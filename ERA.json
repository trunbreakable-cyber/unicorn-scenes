{"history":[{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"gradient","usesPingPong":false,"speed":0.5,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec2 vTextureCoord;uniform vec2 uMousePos;vec3 getColor(int index) {\nswitch(index) {\ncase 0: return vec3(0, 0, 0);\ncase 1: return vec3(0, 0, 0);\ncase 2: return vec3(0, 0, 0);\ncase 3: return vec3(0, 0, 0);\ncase 4: return vec3(0, 0, 0);\ncase 5: return vec3(0, 0, 0);\ncase 6: return vec3(0, 0, 0);\ncase 7: return vec3(0, 0, 0);\ncase 8: return vec3(0, 0, 0);\ncase 9: return vec3(0, 0, 0);\ncase 10: return vec3(0, 0, 0);\ncase 11: return vec3(0, 0, 0);\ncase 12: return vec3(0, 0, 0);\ncase 13: return vec3(0, 0, 0);\ncase 14: return vec3(0, 0, 0);\ncase 15: return vec3(0, 0, 0);\ndefault: return vec3(0.0);\n}\n}const float PI = 3.14159265;vec2 rotate(vec2 coord, float angle) {\nfloat s = sin(angle);\nfloat c = cos(angle);\nreturn vec2(\ncoord.x * c - coord.y * s,\ncoord.x * s + coord.y * c\n);\n}out vec4 fragColor;vec3 getColor(vec2 uv) {return vec3(0, 0, 0);\n}void main() {vec2 uv = vTextureCoord;\nvec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nuv -= pos;\nuv /= (0.5000*2.);\nuv = rotate(uv, (0.0000 - 0.5) * 2. * PI);\nvec4 color = vec4(getColor(uv), 1.0000);\nfragColor = color;\n}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = aTextureCoord;\n}"],"data":{"downSample":0.5,"depth":false,"uniforms":{},"isBackground":true},"id":"effect"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"aurora","usesPingPong":false,"texture":{"src":"https://assets.unicorn.studio/images/FqmFlgX22DYYksu4G0pmfL7UiNX2/Asset 1_v36_combined_1764998939045.png","sampler":"uCustomTexture"},"speed":1,"trackMouse":0.18,"trackAxes":"xy","mouseMomentum":1,"animating":true,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision mediump float;in vec2 vTextureCoord;\nuniform sampler2D uTexture;\nuniform sampler2D uCustomTexture;\nuniform float uTime;\nuniform vec2 uMousePos;\nuniform vec2 uResolution;\nvec3 blend (int blendMode, vec3 src, vec3 dst) {\nreturn src + dst;\n}\nuvec2 pcg2d(uvec2 v) {\nv = v * 1664525u + 1013904223u;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nv ^= v >> 16;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nreturn v;\n}float randFibo(vec2 p) {\nuvec2 v = floatBitsToUint(p);\nv = pcg2d(v);\nuint r = v.x ^ v.y;\nreturn float(r) / float(0xffffffffu);\n}out vec4 fragColor;ivec2 customTexSize;\nfloat customTexAspect;const float PI = 3.14159265359;\nconst float TAU = 6.28318530718;vec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\nreturn a + b*cos( TAU*(c*t+d) );\n}vec3 Tonemap_Reinhard(vec3 x) {\nx *= 4.;\nreturn x / (1.0 + x);\n}float sdCircle(vec2 st, float r) {\nreturn length(st) - r;\n}float getSdf(vec2 st, float iter, float md) {\nreturn sdCircle(st, 0.4500);\n}vec2 turb(vec2 pos, float t, float it, float md, vec2 mPos) {\nmat2 rot = mat2(0.6, -0.8, 0.8, 0.6);\nfloat freq = mix(2., 15., 0.7100);\nfloat amp = (1.0000) * md;\nfloat xp = 1.4;\nfloat time = t * 0.1 + 1.0000;\nfor(float i = 0.; i < 4.; i++) {\nvec2 s = sin(freq * ((pos - mPos) * rot) + i * time + it);\npos += amp * rot[0] * s / freq;\nrot *= mat2(0.6, -0.8, 0.8, 0.6);\namp *= mix(1., max(s.y, s.x), 0.6600);\nfreq *= xp;\n}return pos;\n}float luma(vec3 color) {\nreturn dot(color, vec3(0.299, 0.587, 0.114));\n}const float ITERATIONS = 36.;void main() {\nvec2 uv = vTextureCoord;\nvec4 bg = texture(uTexture, uv);if(1 == 0) {\ncustomTexSize = textureSize(uCustomTexture, 0);\ncustomTexAspect = float(customTexSize.x) / float(customTexSize.y);\n}\nvec3 pp = vec3(0.);\nvec3 bloom = vec3(0.);\nfloat t = uTime * 0.5 + 1.0000;\nvec2 aspect = vec2(uResolution.x/uResolution.y, 1);\nvec2 mousePos = mix(vec2(0), uMousePos - 0.5, 0.1800);\nvec2 pos = (uv * aspect - vec2(0.5, 0.5) * aspect);\nfloat mDist = length(uv * aspect - uMousePos * aspect);\nfloat md = mix(1., smoothstep(1., 5., 1./mDist), 1.0000);\nfloat rotation = 0.0000 * -2.0 * 3.14159265359;\nmat2 rotMatrix = mat2(cos(rotation), -sin(rotation), sin(rotation), cos(rotation));\npos = rotMatrix * pos;\nfloat bm = 0.05;\nvec2 prevPos = turb(pos, t, 0. - 1./ITERATIONS, md, mousePos);\nfloat spacing = mix(1., TAU, 0.6700);\nfloat smoothing = 0.2600;\nfor(float i = 1.; i < ITERATIONS + 1.; i++) {\nfloat iter = i/ITERATIONS;\nvec2 st = turb(pos, t, iter * spacing, md, mousePos);\nfloat d = abs(getSdf(st, iter, md));\nfloat pd = distance(st, prevPos);\nprevPos = st;\nfloat dynamicBlur = exp2(pd * 2.0 * 1.4426950408889634) - 1.0;\nfloat ds = smoothstep(0., 0.0200 * bm + max(dynamicBlur * smoothing, 0.001), d);\nvec3 color = pal(iter * mix(0.1, 1.9, 0.7100) + 0.7200, vec3(0.5), vec3(0.5), vec3(1), vec3(0, 0, 0));\nfloat invd = 1./max(d + dynamicBlur, 0.001);\npp += (ds - 1.) * color;\nbloom += clamp(invd, 0., 250.) * color;\n}pp *= 1./ITERATIONS;\nbloom = bloom / (bloom + 2e4);vec3 color = (-pp + bloom * 3. * 0.3900);\ncolor *= 1.2;\ncolor += (randFibo(gl_FragCoord.xy) - 0.5) / 255.0;\ncolor = (Tonemap_Reinhard(color));\nvec4 auroraColor = vec4(color, 1.);\nauroraColor.rgb = blend(1, bg.rgb, auroraColor.rgb);auroraColor = vec4(mix(bg.rgb, auroraColor.rgb, 0.8000), max(bg.a, luma(auroraColor.rgb)));\nfragColor = auroraColor;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"effect1"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"sdf_shape","usesPingPong":false,"texture":{"src":"https://assets.unicorn.studio/images/FqmFlgX22DYYksu4G0pmfL7UiNX2/Asset 2_v13_combined_1765000376299.png","sampler":"uCustomTexture"},"speed":0.59,"trackMouseMove":0,"trackAxes":"x","mouseMomentum":1,"trackMouse":0,"animating":true,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;\nprecision highp int;in vec2 vTextureCoord;\nuniform sampler2D uTexture;uniform float uTime;uniform vec2 uMousePos;\nuniform vec2 uResolution;uvec2 pcg2d(uvec2 v) {\nv = v * 1664525u + 1013904223u;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nv ^= v >> 16;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nreturn v;\n}float randFibo(vec2 p) {\nuvec2 v = floatBitsToUint(p);\nv = pcg2d(v);\nuint r = v.x ^ v.y;\nreturn float(r) / float(0xffffffffu);\n}const float PI = 3.141592653;\nconst float PI2 = 6.283185306;\nconst int DISP_STEPS = 12;\nconst vec3 viewDir = vec3(0,0, -4.25);ivec2 customTexSize;\nfloat customTexAspect;const mat3 ROT_Y_90 = mat3(\n0.0, 0.0, 1.0,\n0.0, 1.0, 0.0,\n-1.0, 0.0, 0.0\n);const mat3 ROT_Z_90 = mat3(\n0.0, -1.0, 0.0,\n1.0, 0.0, 0.0,\n0.0, 0.0, 1.0\n);const mat3 ROT_X_90 = mat3(\n1.0, 0.0, 0.0,\n0.0, 0.0, -1.0,\n0.0, 1.0, 0.0\n);mat3 rotY(float ang) {\nfloat c = cos(ang), s = sin(ang);\nreturn mat3(c, 0.0, s, 0.0, 1.0, 0.0, -s, 0.0, c);\n}mat3 rotX(float ang) {\nfloat c = cos(ang), s = sin(ang);\nreturn mat3(1.0, 0.0, 0.0, 0.0, c, -s, 0.0, s, c);\n}mat3 rotZ(float ang) {\nfloat c = cos(ang), s = sin(ang);\nreturn mat3(c, -s, 0.0, s, c, 0.0, 0.0, 0.0, 1.0);\n}mat2 rot(float a) {\nfloat s = sin(a);\nfloat c = cos(a);\nreturn mat2(c, -s, s, c);\n}vec3 twistY(vec3 p, float amount) {\nfloat c = cos(amount * p.y);\nfloat s = sin(amount * p.y);\nmat2 m = mat2(c, -s, s, c);\nreturn vec3(m * p.xz, p.y);\n}vec3 twistX(vec3 p, float amount) {\nfloat c = cos(amount * p.x);\nfloat s = sin(amount * p.x);\nmat2 m = mat2(c, -s, s, c);\nreturn vec3(p.x, m * p.yz);\n}float smin(float a, float b, float k) {\nfloat h = max(k - abs(a - b), 0.0);\nreturn min(a, b) - h * h * 0.25 / k;\n}float sphere(vec3 p, float r) {\nreturn length(p) - r;\n}float sdfCylinder(vec3 p, float radius, float height) {\nvec2 d = abs(vec2(length(p.xz) - radius, p.y)) - vec2(radius, height * 0.5);\nreturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}float sdStar5(vec2 p, float r, float rf)\n{\nconst vec2 k1 = vec2(0.809016994375, -0.587785252292);\nconst vec2 k2 = vec2(-k1.x,k1.y);\np.x = abs(p.x);\np -= 2.0*max(dot(k1,p),0.0)*k1;\np -= 2.0*max(dot(k2,p),0.0)*k2;\np.x = abs(p.x);\np.y -= r;\nvec2 ba = rf*vec2(-k1.y,k1.x) - vec2(0,1);\nfloat h = clamp( dot(p,ba)/dot(ba,ba), 0.0, r );\nreturn length(p-ba*h) * sign(p.y*ba.x-p.x*ba.y);\n}float mergedDiscs(vec3 p) {\nfloat result = sdfCylinder(p, 0.7, 0.01 + 0.0000 * 0.5);for(float i = 1.; i < 4.; i++) {\nfloat angle = (i * 45.)/360. * 2.0 * PI;\nmat2 rotZMat = rot(angle);\nvec3 rotatedP = vec3(rotZMat * p.xy, p.z);result = smin(\nresult,\nsdfCylinder(rotatedP, 0.7, 0.01 + 0.0000 * 0.5),\n0.2\n);\n}return max(result, sphere(p, 1.4));\n}vec3 getRepeat(vec3 p) {\nfloat spacing = (1.0000 + 0.0000 * 0.38) * 8.;\nreturn p;\n}vec3 getThreeDRepeat(vec3 p) {\nfloat spacing = (1.0000 + 0.0000 * 0.38) * 8.;\nreturn p;\n}vec3 getAdjustedP(vec3 p) {\nfloat scale = max(1.0000, 0.000000001);\nfloat scaleFactor = 1.0/scale;\nvec3 adjustedP = p * scaleFactor;vec2 twist = vec2(0, -1.29);adjustedP.xy *= vec2(uResolution.x / uResolution.y, 1);adjustedP *= (1. + (0.0000 + 0.01));vec2 mousePos = mix(vec2(0), uMousePos - 0.5, 0.0000);\nvec2 axis = vec2(-1. * vec3(0.07777777777777778, 0.09722222222222222, 0).y - 1. + mousePos.y/PI, vec3(0.07777777777777778, 0.09722222222222222, 0).x + mousePos.x/PI) * 2.;adjustedP = getRepeat(adjustedP);float baseTime = uTime * 0.02;\nfloat timeX = vec3(0, 1.33, 0).x * baseTime;\nfloat timeY = vec3(0, 1.33, 0).y * baseTime;\nfloat timeZ = vec3(0, 1.33, 0).z * baseTime;mat3 rotYMat = rotY(axis.y * PI);\nmat3 rotXMat = rotX(axis.x * PI);\nmat3 rotZMat = rotZ(vec3(0.07777777777777778, 0.09722222222222222, 0).z * 2.0 * PI);mat3 combinedRotation = rotZMat * rotYMat * rotXMat;\nmat3 combinedAnimation = rotZ(timeZ) * rotX(timeX) * rotY(timeY);adjustedP = combinedRotation * adjustedP;\nadjustedP = combinedAnimation * adjustedP;\nadjustedP = getThreeDRepeat(adjustedP);\nadjustedP = mix(adjustedP, twistY(adjustedP, -1.0 * twist.y), step(0.0, abs(twist.y)));\nadjustedP = mix(adjustedP, twistX(adjustedP, -1.0 * twist.x), step(0.0, abs(twist.x)));return adjustedP;\n}float getMergedSDF(vec3 p) {\np = getAdjustedP(p);\nreturn mergedDiscs(p);\n}float fresnel(vec3 eyeVector, vec3 worldNormal, float power) {\nfloat NdotV = abs(dot(eyeVector, worldNormal));\nfloat width = fwidth(dot(eyeVector, worldNormal));\nfloat threshold = 0.2;\nfloat edgeDampFactor = smoothstep(threshold, -threshold, width);\nfloat fresnelFactor = 1.0 - NdotV;\nreturn pow(fresnelFactor, power) * mix(1., edgeDampFactor * 2., 0.5);\n}vec3 noFrostOrDispersion(vec3 rd, vec3 normal) {\nfloat ior = 1.0 / (1.0 + 1.0000 * 0.25);\nvec3 refractedRay = refract(rd, normal, ior);\nreturn texture(uTexture, vTextureCoord - refractedRay.xy).rgb;\n}vec3 frostOrDispersion(vec3 rd, vec3 normal) {\nvec3 refractionColor = vec3(0);\nfloat iorBase = 1. + 1.0000 * 0.25;vec3 dispCoefficients = vec3(0.03, 0.06, 0.1) * 1.0000 * 1.2;for (int i = 0; i < DISP_STEPS; ++i) {\nfloat step = float(i) / float(DISP_STEPS);\nvec3 disp = step * dispCoefficients;\nvec3 ior = 1.0 / (iorBase + disp);vec3 refractedRayR = refract(rd, normal, ior.r);\nvec3 refractedRayG = refract(rd, normal, ior.g);\nvec3 refractedRayB = refract(rd, normal, ior.b);vec2 rayDirOffset = vec2(\nrandFibo(rd.xy + step) - 0.5,\nrandFibo(rd.xy + step + 2.) - 0.5\n) * 0.5;\nrefractedRayR.xy += rayDirOffset * (0.1 + disp.r) * 0.3400;\nrefractedRayG.xy += rayDirOffset * (0.1 + disp.g) * 0.3400;\nrefractedRayB.xy += rayDirOffset * (0.1 + disp.b) * 0.3400;refractionColor.r += texture(uTexture, vTextureCoord - refractedRayR.xy).r;\nrefractionColor.g += texture(uTexture, vTextureCoord - refractedRayG.xy).g;\nrefractionColor.b += texture(uTexture, vTextureCoord - refractedRayB.xy).b;\n}return clamp(refractionColor / float(DISP_STEPS), 0.0, 1.0);\n}vec3 calculateNormal(vec3 p, float eps) {\nvec2 e = vec2(1.0, -1.0) * eps * 0.5;\nreturn normalize(\ne.xyy * getMergedSDF(p + e.xyy) +\ne.yyx * getMergedSDF(p + e.yyx) +\ne.yxy * getMergedSDF(p + e.yxy) +\ne.xxx * getMergedSDF(p + e.xxx)\n);\n}vec3 sampleTexture(vec3 rd, vec3 normal) {return frostOrDispersion(rd, normal);return frostOrDispersion(rd, normal);\nreturn noFrostOrDispersion(rd, normal);\n}float scene(vec3 p) {\nreturn max(0.0000000001, getMergedSDF(p) - (0.0000 + 0.005)) * max(1.0000, 0.000000001);\n}const int STEPS = 128;\nconst float MAX_DISTANCE = 100.0;vec4 rayMarch(vec3 ro, vec3 rd) {\nfloat pixelSize = 0.0025;\nfloat traveled = 0.;\nvec3 entryPoint = vec3(0.0);\nvec3 entryNormal = vec3(0.0);\nfloat partialAlpha = 0.0;\nfloat lastDistance = 0.0;\nfloat smoothing = mix(1., 4., 0.0000);for (int i = 0; i < STEPS; ++i) {\nvec3 currentPos = ro + rd * traveled;\nfloat distance = scene(currentPos);\nfloat progress = float(i)/float(STEPS);\nfloat step = distance * mix(1., 1.5, progress);if (distance > MAX_DISTANCE) break;if (distance < pixelSize) {\npartialAlpha = 1.;\nentryPoint = currentPos;\nentryNormal = calculateNormal(entryPoint, pixelSize * smoothing);\nbreak;\n}lastDistance = distance;traveled += max(step, pixelSize);\nif (traveled > MAX_DISTANCE) break;\n}if (partialAlpha == 0.0) {\nreturn texture(uTexture, vTextureCoord);\n}vec3 samplePosition = mix(rd, entryPoint, 0.0000);vec3 refractionColor = texture(uTexture, vTextureCoord).rgb;refractionColor = sampleTexture(samplePosition, entryNormal);\nvec3 lightDir = vec3(((vec2(vec3(0.25, 0.25, -3).x, 1.-vec3(0.25, 0.25, -3).y) - 0.333) * 3.) - vec2(0.53, -1.1099999999999999), vec3(0.25, 0.25, -3).z);\nvec3 normLightDir = normalize(lightDir);float lightAndShadow = dot(entryNormal, normLightDir);\nvec3 lightColor = mix(vec3(1), vec3(1, 1, 1), 1. - 0.0000);\nvec3 fresnelEffect = vec3(0.0);fresnelEffect = fresnel(rd, entryNormal, 8.0) * 0.7700 * vec3(1, 1, 1);vec3 specularEffect = vec3(0.0);vec3 halfwayDir = normalize(lightDir + rd);\nfloat specFactor = pow(max(dot(entryNormal, halfwayDir), 0.0), 64.0 * 1.0000 + 0.01);\nspecularEffect = specFactor * 1.0000 * lightColor;vec3 combinedEffects = fresnelEffect + specularEffect;\nvec3 finalColor = mix(refractionColor, vec3(1, 1, 1) * lightAndShadow, 0.0000);\nfinalColor += combinedEffects;vec4 outputColor = vec4(finalColor, 1.);return outputColor;\n}out vec4 fragColor;void main() {\nvec4 col = vec4(0);\nvec4 bg = texture(uTexture, vTextureCoord);if(1.0000 <= 0.0001 || 1.0000 <= 0.0001) {\ncol = vec4(0);\nif(1 == 1) {\ncol = bg;\n}\nfragColor = col;\nreturn;\n}vec2 pos = vec2(0.53, -1.1099999999999999) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nvec2 uv = vTextureCoord - pos;\nfloat fovFactor = tan(radians(20.) * 0.5);\nvec3 rd = vec3(uv * fovFactor, 0.5);\ncol = rayMarch(viewDir, rd);\nfloat dither = (randFibo(vTextureCoord.xy) - 0.5) / 255.0;\ncol += dither;col = mix(bg, col, 1.0000);\nfragColor = col;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"effect2"},{"breakpoints":[],"visible":true,"locked":true,"aspectRatio":1,"layerName":"","userDownsample":1,"layerType":"model","isModel":true,"pos":{"type":"Vec3","_x":0.48,"_y":0.98,"_z":0},"modelUrl":"https://assets.unicorn.studio/models/FqmFlgX22DYYksu4G0pmfL7UiNX2/Di-Pietro_Engine_V1-GC-STEP.glb","scale":1,"modelRotation":{"type":"Vec3","_x":0.5,"_y":0.2222222222222222,"_z":0},"lightIntensity":0.06,"ambientLightIntensity":0.49,"fillLightIntensity":0.33,"lightColor":"#ffffff","ambientLightColor":"#000000","fillLightColor":"#ffffff","lightPosition":{"type":"Vec3","_x":0.75,"_y":0.75,"_z":0.75},"materialMetalness":1,"materialRoughness":0.44,"rotationTracking":0,"lightTracking":0,"animationAxis":{"type":"Vec3","_x":0,"_y":0,"_z":1.33},"refractScale":0.5,"chromAbAmount":0.5,"renderNormals":0,"blendMode":"NORMAL","colorMapUrl":"https://assets.unicorn.studio/media/materials/brushed_metal/brushed_metal_color.webp","colorMapScale":1.6,"colorMapPosition":{"type":"Vec2","_x":0.5,"_y":0.5},"colorMapIntensity":0.6,"normalMapUrl":"https://assets.unicorn.studio/media/materials/brushed_metal/brushed_metal_normal.webp","normalMapScale":1,"normalMapPosition":{"type":"Vec2","_x":0.5,"_y":0.5},"normalMapIntensity":1,"quality":"high","environmentMapIntensity":1,"environmentMapUrl":"","extrudeDepth":10,"bevelEnabled":false,"bevelThickness":1,"bevelSize":1,"bevelSegments":2,"glassIOR":1.26,"glassThickness":0.5,"glassRoughness":0,"glassTint":"#ffffff","glassDispersion":0,"contextType":"webgl","trackAxes":"xy","trackMouse":0,"mouseMomentum":0,"states":{"appear":[],"scroll":[],"hover":[]},"animating":true,"opacity":1,"speed":0.22,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec2 vTextureCoord;\nin vec3 vVertexPosition;uniform sampler2D uBgTexture;\nuniform sampler2D uTexture;uniform float uOpacity;\nout vec4 fragColor;void main() {\nvec4 bgColor = texture(uBgTexture, vTextureCoord);\nvec4 fgColor = texture(uTexture, vTextureCoord);\nvec4 color = vec4(1.0, 0.0, 0.0, 1.0);if(uOpacity < 0.001) {\nfragColor = bgColor;\nreturn;\n}color = mix(bgColor, mix(bgColor, fgColor, fgColor.a), uOpacity);fragColor = color;\n}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"uniforms":{}},"moduleRef":"model_renderer","id":"model"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"fog","usesPingPong":false,"speed":0.54,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"animating":true,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;\nprecision highp int;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uTexture;\nuniform float uTime;\nuniform vec2 uMousePos;\nuniform vec2 uResolution;\nfloat ease (int easingFunc, float t) {\nreturn t;\n}\nfloat getExponentialWeight(int index) {\nswitch(index) {\ncase 0: return 1.0000000000;\ncase 1: return 0.7165313106;\ncase 2: return 0.5134171190;\ncase 3: return 0.3678794412;\ncase 4: return 0.2636050919;\ncase 5: return 0.1888756057;\ncase 6: return 0.1353352832;\ncase 7: return 0.0969670595;\ncase 8: return 0.0694877157;\ndefault: return 0.0;\n}\n}out vec4 fragColor;const int kernelSize = 36;\nmat2 rot(float a) {\nreturn mat2(cos(a),-sin(a),sin(a),cos(a));\n}const float PHI = 1.618033988;\nconst float PI = 3.14159265359;float dot_noise(vec3 p) {\nconst mat3 GOLD = mat3(\n-0.571464913, +0.814921382, +0.096597072,\n-0.278044873, -0.303026659, +0.911518454,\n+0.772087367, +0.494042493, +0.399753815);\nreturn dot(cos(GOLD * p), sin(PHI * p * GOLD));\n}float cheap_fbm(vec3 p) {\nmat2 rota = mat2(0.6, -0.8, 0.8, 0.6);\nfloat nos = 0.;\nfloat amp = 1. + 0.8100 * 10.;\nfloat xp = sqrt(2.);\nfloat halfxp = xp * 0.5;\nfor(int i = 0; i < 9; i++) {\nfloat theta = uTime * 0.05 + float(i);\np.xy *= xp;\np.xy += sin(rota * p.xy * xp + theta) * 0.2;\nfloat nz = dot_noise(vec3(p.xy * rota, p.z + theta));\nnos += nz * amp * rota[0][0];\namp *= halfxp;\nrota *= mat2(0.6, -0.8, 0.8, 0.6);\n}\nnos *= 1./float(9);\nfloat density = -3. + 0.5200 * 6.;\nreturn smoothstep(-3., 3., nos + density);\n}float fnoise(vec2 uv) {\nfloat aspectRatio = uResolution.x/uResolution.y;\nvec2 aspect = vec2(aspectRatio, 1);\nfloat multiplier = 10.0 * (0.9700 / ((aspectRatio + 1.) / 2.));\nvec2 st = ((uv * aspect - vec2(0.315450643776824, 0.4605150214592275) * aspect)) * multiplier * rot((0.2484 - 0.125) * 2. * PI);vec2 mPos = vec2(0.315450643776824, 0.4605150214592275) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nvec2 pos = mix(vec2(0.315450643776824, 0.4605150214592275), mPos, floor(1.0000));\nfloat dist = ease(0, max(0.,1.-distance(uv * aspect, mPos * aspect) * 4. * (1. - 1.0000)));if (0 == 1) {\ndist = max(0., (0.5 - dist));\n}\nfloat time = uTime * 0.05;\nvec2 drift = vec2(time * 0.2) * 2.0 * 0.6700;\nfloat fbm = cheap_fbm(vec3(st - drift, time)) * dist;\nfbm = fbm / (1. + fbm);\nreturn fbm;\n}vec4 ExponentialBlur(sampler2D tex, vec2 uv, vec2 direction) {\nvec4 color = vec4(0.0);\nfloat total_weight = 0.0;float fogNoise = fnoise(uv);\nfloat radius = 8.0 * fogNoise * max(0.4200, 0.1);\nradius = mix(0.01, 0.03, radius);vec2 dir = normalize(direction) / vec2(uResolution.x/uResolution.y, 1);vec4 center = texture(tex, uv);\nfloat center_weight = getExponentialWeight(0);\ncolor += center * center_weight;\ntotal_weight += center_weight;for (int i = 1; i <= 8; i++) {\nfloat weight = getExponentialWeight(i);\nfloat offset = radius * float(i) / 8.0;\nvec4 sample1 = texture(tex, uv + offset * dir);\nvec4 sample2 = texture(tex, uv - offset * dir);\ncolor += (sample1 + sample2) * weight;\ntotal_weight += 2.0 * weight;\n}\nfloat scatter = radius * 2.;\ncolor += (\ntexture(tex, uv + scatter * dir) +\ntexture(tex, uv - scatter * dir)\n) * 0.0694877157;return color / total_weight;\n}vec4 blur(vec2 uv, vec2 direction) {\nreturn ExponentialBlur(uTexture, uv, direction);\n}vec4 getColor(vec2 uv) {\nreturn blur(uv, vec2(1, 0));\n}void main() {\nvec2 uv = vTextureCoord;\nvec4 color = getColor(uv);\nfragColor = color;}","#version 300 es\nprecision highp float;\nprecision highp int;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uTexture;\nuniform float uTime;\nuniform vec2 uMousePos;\nuniform vec2 uResolution;\nfloat ease (int easingFunc, float t) {\nreturn t;\n}\nfloat getExponentialWeight(int index) {\nswitch(index) {\ncase 0: return 1.0000000000;\ncase 1: return 0.7165313106;\ncase 2: return 0.5134171190;\ncase 3: return 0.3678794412;\ncase 4: return 0.2636050919;\ncase 5: return 0.1888756057;\ncase 6: return 0.1353352832;\ncase 7: return 0.0969670595;\ncase 8: return 0.0694877157;\ndefault: return 0.0;\n}\n}out vec4 fragColor;const int kernelSize = 36;\nmat2 rot(float a) {\nreturn mat2(cos(a),-sin(a),sin(a),cos(a));\n}const float PHI = 1.618033988;\nconst float PI = 3.14159265359;float dot_noise(vec3 p) {\nconst mat3 GOLD = mat3(\n-0.571464913, +0.814921382, +0.096597072,\n-0.278044873, -0.303026659, +0.911518454,\n+0.772087367, +0.494042493, +0.399753815);\nreturn dot(cos(GOLD * p), sin(PHI * p * GOLD));\n}float cheap_fbm(vec3 p) {\nmat2 rota = mat2(0.6, -0.8, 0.8, 0.6);\nfloat nos = 0.;\nfloat amp = 1. + 0.8100 * 10.;\nfloat xp = sqrt(2.);\nfloat halfxp = xp * 0.5;\nfor(int i = 0; i < 9; i++) {\nfloat theta = uTime * 0.05 + float(i);\np.xy *= xp;\np.xy += sin(rota * p.xy * xp + theta) * 0.2;\nfloat nz = dot_noise(vec3(p.xy * rota, p.z + theta));\nnos += nz * amp * rota[0][0];\namp *= halfxp;\nrota *= mat2(0.6, -0.8, 0.8, 0.6);\n}\nnos *= 1./float(9);\nfloat density = -3. + 0.5200 * 6.;\nreturn smoothstep(-3., 3., nos + density);\n}float fnoise(vec2 uv) {\nfloat aspectRatio = uResolution.x/uResolution.y;\nvec2 aspect = vec2(aspectRatio, 1);\nfloat multiplier = 10.0 * (0.9700 / ((aspectRatio + 1.) / 2.));\nvec2 st = ((uv * aspect - vec2(0.315450643776824, 0.4605150214592275) * aspect)) * multiplier * rot((0.2484 - 0.125) * 2. * PI);vec2 mPos = vec2(0.315450643776824, 0.4605150214592275) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nvec2 pos = mix(vec2(0.315450643776824, 0.4605150214592275), mPos, floor(1.0000));\nfloat dist = ease(0, max(0.,1.-distance(uv * aspect, mPos * aspect) * 4. * (1. - 1.0000)));if (0 == 1) {\ndist = max(0., (0.5 - dist));\n}\nfloat time = uTime * 0.05;\nvec2 drift = vec2(time * 0.2) * 2.0 * 0.6700;\nfloat fbm = cheap_fbm(vec3(st - drift, time)) * dist;\nfbm = fbm / (1. + fbm);\nreturn fbm;\n}vec4 ExponentialBlur(sampler2D tex, vec2 uv, vec2 direction) {\nvec4 color = vec4(0.0);\nfloat total_weight = 0.0;float fogNoise = fnoise(uv);\nfloat radius = 8.0 * fogNoise * max(0.4200, 0.1);\nradius = mix(0.01, 0.03, radius);vec2 dir = normalize(direction) / vec2(uResolution.x/uResolution.y, 1);vec4 center = texture(tex, uv);\nfloat center_weight = getExponentialWeight(0);\ncolor += center * center_weight;\ntotal_weight += center_weight;for (int i = 1; i <= 8; i++) {\nfloat weight = getExponentialWeight(i);\nfloat offset = radius * float(i) / 8.0;\nvec4 sample1 = texture(tex, uv + offset * dir);\nvec4 sample2 = texture(tex, uv - offset * dir);\ncolor += (sample1 + sample2) * weight;\ntotal_weight += 2.0 * weight;\n}\nfloat scatter = radius * 2.;\ncolor += (\ntexture(tex, uv + scatter * dir) +\ntexture(tex, uv - scatter * dir)\n) * 0.0694877157;return color / total_weight;\n}vec4 blur(vec2 uv, vec2 direction) {\nreturn ExponentialBlur(uTexture, uv, direction);\n}vec4 getColor(vec2 uv) {\nreturn blur(uv, vec2(0, 1));\n}void main() {\nvec2 uv = vTextureCoord;\nvec4 color = getColor(uv);\nfragColor = color;}","#version 300 es\nprecision highp float;\nprecision highp int;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uTexture;\nuniform float uTime;\nuniform vec2 uMousePos;\nuniform vec2 uResolution;\nfloat ease (int easingFunc, float t) {\nreturn t;\n}\nfloat getExponentialWeight(int index) {\nswitch(index) {\ncase 0: return 1.0000000000;\ncase 1: return 0.7165313106;\ncase 2: return 0.5134171190;\ncase 3: return 0.3678794412;\ncase 4: return 0.2636050919;\ncase 5: return 0.1888756057;\ncase 6: return 0.1353352832;\ncase 7: return 0.0969670595;\ncase 8: return 0.0694877157;\ndefault: return 0.0;\n}\n}out vec4 fragColor;const int kernelSize = 36;\nmat2 rot(float a) {\nreturn mat2(cos(a),-sin(a),sin(a),cos(a));\n}const float PHI = 1.618033988;\nconst float PI = 3.14159265359;float dot_noise(vec3 p) {\nconst mat3 GOLD = mat3(\n-0.571464913, +0.814921382, +0.096597072,\n-0.278044873, -0.303026659, +0.911518454,\n+0.772087367, +0.494042493, +0.399753815);\nreturn dot(cos(GOLD * p), sin(PHI * p * GOLD));\n}float cheap_fbm(vec3 p) {\nmat2 rota = mat2(0.6, -0.8, 0.8, 0.6);\nfloat nos = 0.;\nfloat amp = 1. + 0.8100 * 10.;\nfloat xp = sqrt(2.);\nfloat halfxp = xp * 0.5;\nfor(int i = 0; i < 9; i++) {\nfloat theta = uTime * 0.05 + float(i);\np.xy *= xp;\np.xy += sin(rota * p.xy * xp + theta) * 0.2;\nfloat nz = dot_noise(vec3(p.xy * rota, p.z + theta));\nnos += nz * amp * rota[0][0];\namp *= halfxp;\nrota *= mat2(0.6, -0.8, 0.8, 0.6);\n}\nnos *= 1./float(9);\nfloat density = -3. + 0.5200 * 6.;\nreturn smoothstep(-3., 3., nos + density);\n}float fnoise(vec2 uv) {\nfloat aspectRatio = uResolution.x/uResolution.y;\nvec2 aspect = vec2(aspectRatio, 1);\nfloat multiplier = 10.0 * (0.9700 / ((aspectRatio + 1.) / 2.));\nvec2 st = ((uv * aspect - vec2(0.315450643776824, 0.4605150214592275) * aspect)) * multiplier * rot((0.2484 - 0.125) * 2. * PI);vec2 mPos = vec2(0.315450643776824, 0.4605150214592275) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nvec2 pos = mix(vec2(0.315450643776824, 0.4605150214592275), mPos, floor(1.0000));\nfloat dist = ease(0, max(0.,1.-distance(uv * aspect, mPos * aspect) * 4. * (1. - 1.0000)));if (0 == 1) {\ndist = max(0., (0.5 - dist));\n}\nfloat time = uTime * 0.05;\nvec2 drift = vec2(time * 0.2) * 2.0 * 0.6700;\nfloat fbm = cheap_fbm(vec3(st - drift, time)) * dist;\nfbm = fbm / (1. + fbm);\nreturn fbm;\n}vec4 ExponentialBlur(sampler2D tex, vec2 uv, vec2 direction) {\nvec4 color = vec4(0.0);\nfloat total_weight = 0.0;float fogNoise = fnoise(uv);\nfloat radius = 8.0 * fogNoise * max(0.4200, 0.1);\nradius = mix(0.01, 0.03, radius);vec2 dir = normalize(direction) / vec2(uResolution.x/uResolution.y, 1);vec4 center = texture(tex, uv);\nfloat center_weight = getExponentialWeight(0);\ncolor += center * center_weight;\ntotal_weight += center_weight;for (int i = 1; i <= 8; i++) {\nfloat weight = getExponentialWeight(i);\nfloat offset = radius * float(i) / 8.0;\nvec4 sample1 = texture(tex, uv + offset * dir);\nvec4 sample2 = texture(tex, uv - offset * dir);\ncolor += (sample1 + sample2) * weight;\ntotal_weight += 2.0 * weight;\n}\nfloat scatter = radius * 2.;\ncolor += (\ntexture(tex, uv + scatter * dir) +\ntexture(tex, uv - scatter * dir)\n) * 0.0694877157;return color / total_weight;\n}vec4 blur(vec2 uv, vec2 direction) {\nreturn ExponentialBlur(uTexture, uv, direction);\n}vec4 getColor(vec2 uv) {\nreturn blur(uv, vec2(1, 1));\n}void main() {\nvec2 uv = vTextureCoord;\nvec4 color = getColor(uv);\nfragColor = color;}","#version 300 es\nprecision highp float;\nprecision highp int;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uTexture;\nuniform float uTime;\nuniform vec2 uMousePos;\nuniform vec2 uResolution;\nfloat ease (int easingFunc, float t) {\nreturn t;\n}\nfloat getExponentialWeight(int index) {\nswitch(index) {\ncase 0: return 1.0000000000;\ncase 1: return 0.7165313106;\ncase 2: return 0.5134171190;\ncase 3: return 0.3678794412;\ncase 4: return 0.2636050919;\ncase 5: return 0.1888756057;\ncase 6: return 0.1353352832;\ncase 7: return 0.0969670595;\ncase 8: return 0.0694877157;\ndefault: return 0.0;\n}\n}out vec4 fragColor;const int kernelSize = 36;\nmat2 rot(float a) {\nreturn mat2(cos(a),-sin(a),sin(a),cos(a));\n}const float PHI = 1.618033988;\nconst float PI = 3.14159265359;float dot_noise(vec3 p) {\nconst mat3 GOLD = mat3(\n-0.571464913, +0.814921382, +0.096597072,\n-0.278044873, -0.303026659, +0.911518454,\n+0.772087367, +0.494042493, +0.399753815);\nreturn dot(cos(GOLD * p), sin(PHI * p * GOLD));\n}float cheap_fbm(vec3 p) {\nmat2 rota = mat2(0.6, -0.8, 0.8, 0.6);\nfloat nos = 0.;\nfloat amp = 1. + 0.8100 * 10.;\nfloat xp = sqrt(2.);\nfloat halfxp = xp * 0.5;\nfor(int i = 0; i < 9; i++) {\nfloat theta = uTime * 0.05 + float(i);\np.xy *= xp;\np.xy += sin(rota * p.xy * xp + theta) * 0.2;\nfloat nz = dot_noise(vec3(p.xy * rota, p.z + theta));\nnos += nz * amp * rota[0][0];\namp *= halfxp;\nrota *= mat2(0.6, -0.8, 0.8, 0.6);\n}\nnos *= 1./float(9);\nfloat density = -3. + 0.5200 * 6.;\nreturn smoothstep(-3., 3., nos + density);\n}float fnoise(vec2 uv) {\nfloat aspectRatio = uResolution.x/uResolution.y;\nvec2 aspect = vec2(aspectRatio, 1);\nfloat multiplier = 10.0 * (0.9700 / ((aspectRatio + 1.) / 2.));\nvec2 st = ((uv * aspect - vec2(0.315450643776824, 0.4605150214592275) * aspect)) * multiplier * rot((0.2484 - 0.125) * 2. * PI);vec2 mPos = vec2(0.315450643776824, 0.4605150214592275) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nvec2 pos = mix(vec2(0.315450643776824, 0.4605150214592275), mPos, floor(1.0000));\nfloat dist = ease(0, max(0.,1.-distance(uv * aspect, mPos * aspect) * 4. * (1. - 1.0000)));if (0 == 1) {\ndist = max(0., (0.5 - dist));\n}\nfloat time = uTime * 0.05;\nvec2 drift = vec2(time * 0.2) * 2.0 * 0.6700;\nfloat fbm = cheap_fbm(vec3(st - drift, time)) * dist;\nfbm = fbm / (1. + fbm);\nreturn fbm;\n}vec4 ExponentialBlur(sampler2D tex, vec2 uv, vec2 direction) {\nvec4 color = vec4(0.0);\nfloat total_weight = 0.0;float fogNoise = fnoise(uv);\nfloat radius = 8.0 * fogNoise * max(0.4200, 0.1);\nradius = mix(0.01, 0.03, radius);vec2 dir = normalize(direction) / vec2(uResolution.x/uResolution.y, 1);vec4 center = texture(tex, uv);\nfloat center_weight = getExponentialWeight(0);\ncolor += center * center_weight;\ntotal_weight += center_weight;for (int i = 1; i <= 8; i++) {\nfloat weight = getExponentialWeight(i);\nfloat offset = radius * float(i) / 8.0;\nvec4 sample1 = texture(tex, uv + offset * dir);\nvec4 sample2 = texture(tex, uv - offset * dir);\ncolor += (sample1 + sample2) * weight;\ntotal_weight += 2.0 * weight;\n}\nfloat scatter = radius * 2.;\ncolor += (\ntexture(tex, uv + scatter * dir) +\ntexture(tex, uv - scatter * dir)\n) * 0.0694877157;return color / total_weight;\n}vec4 blur(vec2 uv, vec2 direction) {\nreturn ExponentialBlur(uTexture, uv, direction);\n}vec4 getColor(vec2 uv) {\nreturn blur(uv, vec2(1, -1));\n}void main() {\nvec2 uv = vTextureCoord;\nvec4 color = getColor(uv);\nfragColor = color;}","#version 300 es\nprecision highp float;\nprecision highp int;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uTexture;\nuniform sampler2D uBgTexture;\nuniform float uTime;\nuniform vec2 uMousePos;\nuniform vec2 uResolution;\nfloat ease (int easingFunc, float t) {\nreturn t;\n}\nuvec2 pcg2d(uvec2 v) {\nv = v * 1664525u + 1013904223u;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nv ^= v >> 16;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nreturn v;\n}float randFibo(vec2 p) {\nuvec2 v = floatBitsToUint(p);\nv = pcg2d(v);\nuint r = v.x ^ v.y;\nreturn float(r) / float(0xffffffffu);\n}vec3 blend (int blendMode, vec3 src, vec3 dst) {\nreturn src + dst;\n}out vec4 fragColor;const int kernelSize = 36;\nmat2 rot(float a) {\nreturn mat2(cos(a),-sin(a),sin(a),cos(a));\n}vec3 Tonemap_ACES(vec3 x) {\nconst float a = 2.51;\nconst float b = 0.03;\nconst float c = 2.43;\nconst float d = 0.59;\nconst float e = 0.14;\nreturn (x * (a * x + b)) / (x * (c * x + d) + e);\n}vec3 chromatic_aberration(vec3 color, vec2 uv, float amount) {\nvec2 offset = normalize(vTextureCoord - 0.5) * amount / vec2(uResolution.x/uResolution.y, 1);\nvec4 left = texture(uTexture, uv - offset);\nvec4 right = texture(uTexture, uv + offset);color.r = left.r;\ncolor.b = right.b;return color;\n}const float PHI = 1.618033988;\nconst float PI = 3.14159265359;float dot_noise(vec3 p) {\nconst mat3 GOLD = mat3(\n-0.571464913, +0.814921382, +0.096597072,\n-0.278044873, -0.303026659, +0.911518454,\n+0.772087367, +0.494042493, +0.399753815);\nreturn dot(cos(GOLD * p), sin(PHI * p * GOLD));\n}float cheap_fbm(vec3 p) {\nmat2 rota = mat2(0.6, -0.8, 0.8, 0.6);\nfloat nos = 0.;\nfloat amp = 1. + 0.8100 * 10.;\nfloat xp = sqrt(2.);\nfloat halfxp = xp * 0.5;\nfor(int i = 0; i < 9; i++) {\nfloat theta = uTime * 0.05 + float(i);\np.xy *= xp;\np.xy += sin(rota * p.xy * xp + theta) * 0.2;\nfloat nz = dot_noise(vec3(p.xy * rota, p.z + theta));\nnos += nz * amp * rota[0][0];\namp *= halfxp;\nrota *= mat2(0.6, -0.8, 0.8, 0.6);\n}\nnos *= 1./float(9);\nfloat density = -3. + 0.5200 * 6.;\nreturn smoothstep(-3., 3., nos + density);\n}float fnoise(vec2 uv) {\nfloat aspectRatio = uResolution.x/uResolution.y;\nvec2 aspect = vec2(aspectRatio, 1);\nfloat multiplier = 10.0 * (0.9700 / ((aspectRatio + 1.) / 2.));\nvec2 st = ((uv * aspect - vec2(0.315450643776824, 0.4605150214592275) * aspect)) * multiplier * rot((0.2484 - 0.125) * 2. * PI);vec2 mPos = vec2(0.315450643776824, 0.4605150214592275) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nvec2 pos = mix(vec2(0.315450643776824, 0.4605150214592275), mPos, floor(1.0000));\nfloat dist = ease(0, max(0.,1.-distance(uv * aspect, mPos * aspect) * 4. * (1. - 1.0000)));if (0 == 1) {\ndist = max(0., (0.5 - dist));\n}\nfloat time = uTime * 0.05;\nvec2 drift = vec2(time * 0.2) * 2.0 * 0.6700;\nfloat fbm = cheap_fbm(vec3(st - drift, time)) * dist;\nfbm = fbm / (1. + fbm);\nreturn fbm;\n}vec4 fogComposite(vec2 uv) {\nvec4 bg = texture(uBgTexture, uv);\nvec4 blur = texture(uTexture, uv);\nfloat aspectRatio = uResolution.x/uResolution.y;\nfloat fogNoise = fnoise(uv);\nfloat fogMask = clamp(fogNoise * 2., 0., 1.);vec3 grain = vec3(randFibo(uv + fogNoise));blur.rgb = chromatic_aberration(blur.rgb, uv, fogMask * 0.01 * 0.4200 * (0.2900 * 2.5));\nblur.rgb = Tonemap_ACES(blur.rgb * (1.2700 + 0.5)) + grain * 0.05;\nvec4 foggedBlur = vec4(blur.rgb * vec3(0.0196078431372549, 0.11372549019607843, 0.19215686274509805), blur.a);\nfoggedBlur.rgb += (0.0000 * 0.25 * fogMask * vec3(0.0196078431372549, 0.11372549019607843, 0.19215686274509805));\nfoggedBlur.rgb = blend(1, bg.rgb, foggedBlur.rgb * fogMask);\nreturn foggedBlur;\n}vec4 getColor(vec2 uv) {\nreturn fogComposite(uv);\n}void main() {\nvec2 uv = vTextureCoord;\nvec4 color = getColor(uv);\nfragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"downSample":0.25,"depth":false,"uniforms":{},"isBackground":false,"passes":[{"prop":"pass","value":1,"downSample":0.25},{"prop":"pass","value":2,"downSample":0.25},{"prop":"pass","value":3,"downSample":0.25},{"prop":"pass","value":4,"includeBg":true}]},"id":"effect3"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"godrays","usesPingPong":false,"trackMouse":0.52,"trackAxes":"xy","mouseMomentum":1,"texture":false,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;\nprecision highp int;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uTexture;const float MAX_ITERATIONS = 64.;\nconst float PI2 = 6.28318530718;\nconst float EPSILON = 0.0001;\nconst float stepFactor = 0.0098;vec4 getBrightAreas(vec2 uv) {\nvec4 color = texture(uTexture, uv);\nfloat lum = dot(color.rgb, vec3(0.299, 0.587, 0.114));\ncolor = color * smoothstep(0.0000 - 0.1, 0.0000, lum);\nreturn color;\n}vec4 getColor(vec2 uv) {\nreturn getBrightAreas(uv);\n}out vec4 fragColor;void main() {\nvec2 uv = vTextureCoord;\nvec4 color = getColor(uv);\nif(0 == 2) {\nfragColor = color;} else {\nfragColor = color;\n}\n}","#version 300 es\nprecision highp float;\nprecision highp int;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uTexture;uniform vec2 uMousePos;uvec2 pcg2d(uvec2 v) {\nv = v * 1664525u + 1013904223u;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nv ^= v >> 16;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nreturn v;\n}float randFibo(vec2 p) {\nuvec2 v = floatBitsToUint(p);\nv = pcg2d(v);\nuint r = v.x ^ v.y;\nreturn float(r) / float(0xffffffffu);\n}const float MAX_ITERATIONS = 64.;\nconst float PI2 = 6.28318530718;\nconst float EPSILON = 0.0001;\nconst float stepFactor = 0.0098;vec4 godRays(vec2 st, float decay) {\nvec3 color = vec3(0);\nfloat offset = (0.25 + min(1., 0.7400)) * stepFactor;\nvec2 pos = vec2(0.5197628458498024, 0.5138339920948616) - mix(vec2(0), (vec2(1. - uMousePos.x, 1. - uMousePos.y) - 0.5), 0.5200);\nfloat weight = 1.0;\nfloat bnoz = randFibo(st) * 0.7400;\nfloat distanceInfo = 0.0;\nvec2 marchPos = st;for (float i = 0.0; i < MAX_ITERATIONS; i += 4.0) {\nfor (float j = 0.0; j < 4.0; j++) {\nfloat bno = randFibo(st + vec2(i/MAX_ITERATIONS + j/4.0)) * 0.7400;\nvec2 offbno = vec2(cos(bno) - 0.5, sin(bno) - 0.5);\nfloat x = min(0.999, (i + j) * offset) + bnoz * 0.02;\nfloat y = min(0.999, (i + j));\nmarchPos = st * (1.0 - x) + vec2(x * 0.5) + (pos - 0.5) * x + offbno * 0.02 * 6.5100 * x;\ncolor += texture(uTexture, marchPos).rgb * weight;\ndistanceInfo += y * weight;\nweight *= decay;\nif(weight < 0.01) break;\n}\n}\nreturn vec4(color / MAX_ITERATIONS, distance(st, marchPos));\n}vec4 getGodRays(vec2 uv) {\nif(1.0000 == 0.) {\nreturn vec4(0);\n}\nvec4 rays = godRays(uv, 0.972);\nrays.rgb *= vec3(0.25882352941176473, 0.24313725490196078, 0.30196078431372547);\nvec4 color;\ncolor.rgb = rays.rgb;\ncolor.a = rays.a;\nreturn color;\n}vec4 getColor(vec2 uv) {\nreturn getGodRays(uv);\n}out vec4 fragColor;void main() {\nvec2 uv = vTextureCoord;\nvec4 color = getColor(uv);\nif(1 == 2) {\nfragColor = color;} else {\nfragColor = color;\n}\n}","#version 300 es\nprecision highp float;\nprecision highp int;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uTexture;\nuniform sampler2D uBgTexture;\nuniform sampler2D uBlueNoise;uniform vec2 uResolution;const float MAX_ITERATIONS = 64.;\nconst float PI2 = 6.28318530718;\nconst float EPSILON = 0.0001;\nconst float stepFactor = 0.0098;float luma(vec4 color) {\nreturn dot(color.rgb, vec3(0.299, 0.587, 0.114));\n}float getBlueNoiseOffset(vec2 st) {\nivec2 texSize = ivec2(512, 512);\nvec4 blueNoise = texelFetch(uBlueNoise, ivec2(fract(st * (uResolution)/vec2(texSize) * vec2(texSize.x/texSize.y, 1.0)) * vec2(texSize)) % texSize, 0);\nreturn mod((blueNoise.r - 0.5) * PI2, PI2);\n}vec4 composite(vec2 uv) {\nvec4 godrays = texture(uTexture, uv);\nfloat distanceInfo = godrays.a;\nfloat luminance = luma(godrays);\nfloat blueNoise = getBlueNoiseOffset(uv) - 0.5;\nvec2 circNoise = vec2(cos(blueNoise), sin(blueNoise));\nfloat brightnessScale = (1. - (luminance + 0.25));\nvec2 offset = circNoise * 0.05 * pow(brightnessScale, 3.) * distanceInfo * 2.;\nvec4 color = texture(uTexture, uv + offset);\nvec4 bg = texture(uBgTexture, uv);color.rgb = bg.rgb + (color.rgb * 2.9 * 1.0000 + blueNoise * 0.001);\ncolor.a = bg.a + color.r;\nreturn color;\n}vec4 getColor(vec2 uv) {\nreturn composite(uv);\n}out vec4 fragColor;void main() {\nvec2 uv = vTextureCoord;\nvec4 color = getColor(uv);\nif(2 == 2) {\nfragColor = color;} else {\nfragColor = color;\n}\n}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":false,"passes":[{"prop":"pass","value":1,"downSample":0.5},{"prop":"pass","value":2,"includeBg":true}],"texture":{"src":"https://assets.unicorn.studio/media/blue_noise_med.png","sampler":"uBlueNoise"}},"id":"effect4"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"godrays","usesPingPong":false,"trackMouse":0.52,"trackAxes":"xy","mouseMomentum":1,"texture":false,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;\nprecision highp int;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uTexture;const float MAX_ITERATIONS = 64.;\nconst float PI2 = 6.28318530718;\nconst float EPSILON = 0.0001;\nconst float stepFactor = 0.0098;vec4 getBrightAreas(vec2 uv) {\nvec4 color = texture(uTexture, uv);\nfloat lum = dot(color.rgb, vec3(0.299, 0.587, 0.114));\ncolor = color * smoothstep(0.0000 - 0.1, 0.0000, lum);\nreturn color;\n}vec4 getColor(vec2 uv) {\nreturn getBrightAreas(uv);\n}out vec4 fragColor;void main() {\nvec2 uv = vTextureCoord;\nvec4 color = getColor(uv);\nif(0 == 2) {\nfragColor = color;} else {\nfragColor = color;\n}\n}","#version 300 es\nprecision highp float;\nprecision highp int;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uTexture;uniform vec2 uMousePos;uvec2 pcg2d(uvec2 v) {\nv = v * 1664525u + 1013904223u;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nv ^= v >> 16;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nreturn v;\n}float randFibo(vec2 p) {\nuvec2 v = floatBitsToUint(p);\nv = pcg2d(v);\nuint r = v.x ^ v.y;\nreturn float(r) / float(0xffffffffu);\n}const float MAX_ITERATIONS = 64.;\nconst float PI2 = 6.28318530718;\nconst float EPSILON = 0.0001;\nconst float stepFactor = 0.0098;vec4 godRays(vec2 st, float decay) {\nvec3 color = vec3(0);\nfloat offset = (0.25 + min(1., 0.7400)) * stepFactor;\nvec2 pos = vec2(0.5197628458498024, 0.5138339920948616) - mix(vec2(0), (vec2(1. - uMousePos.x, 1. - uMousePos.y) - 0.5), 0.5200);\nfloat weight = 1.0;\nfloat bnoz = randFibo(st) * 0.7400;\nfloat distanceInfo = 0.0;\nvec2 marchPos = st;for (float i = 0.0; i < MAX_ITERATIONS; i += 4.0) {\nfor (float j = 0.0; j < 4.0; j++) {\nfloat bno = randFibo(st + vec2(i/MAX_ITERATIONS + j/4.0)) * 0.7400;\nvec2 offbno = vec2(cos(bno) - 0.5, sin(bno) - 0.5);\nfloat x = min(0.999, (i + j) * offset) + bnoz * 0.02;\nfloat y = min(0.999, (i + j));\nmarchPos = st * (1.0 - x) + vec2(x * 0.5) + (pos - 0.5) * x + offbno * 0.02 * 6.5100 * x;\ncolor += texture(uTexture, marchPos).rgb * weight;\ndistanceInfo += y * weight;\nweight *= decay;\nif(weight < 0.01) break;\n}\n}\nreturn vec4(color / MAX_ITERATIONS, distance(st, marchPos));\n}vec4 getGodRays(vec2 uv) {\nif(1.0000 == 0.) {\nreturn vec4(0);\n}\nvec4 rays = godRays(uv, 0.972);\nrays.rgb *= vec3(0.25882352941176473, 0.24313725490196078, 0.30196078431372547);\nvec4 color;\ncolor.rgb = rays.rgb;\ncolor.a = rays.a;\nreturn color;\n}vec4 getColor(vec2 uv) {\nreturn getGodRays(uv);\n}out vec4 fragColor;void main() {\nvec2 uv = vTextureCoord;\nvec4 color = getColor(uv);\nif(1 == 2) {\nfragColor = color;} else {\nfragColor = color;\n}\n}","#version 300 es\nprecision highp float;\nprecision highp int;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uTexture;\nuniform sampler2D uBgTexture;\nuniform sampler2D uBlueNoise;uniform vec2 uResolution;const float MAX_ITERATIONS = 64.;\nconst float PI2 = 6.28318530718;\nconst float EPSILON = 0.0001;\nconst float stepFactor = 0.0098;float luma(vec4 color) {\nreturn dot(color.rgb, vec3(0.299, 0.587, 0.114));\n}float getBlueNoiseOffset(vec2 st) {\nivec2 texSize = ivec2(512, 512);\nvec4 blueNoise = texelFetch(uBlueNoise, ivec2(fract(st * (uResolution)/vec2(texSize) * vec2(texSize.x/texSize.y, 1.0)) * vec2(texSize)) % texSize, 0);\nreturn mod((blueNoise.r - 0.5) * PI2, PI2);\n}vec4 composite(vec2 uv) {\nvec4 godrays = texture(uTexture, uv);\nfloat distanceInfo = godrays.a;\nfloat luminance = luma(godrays);\nfloat blueNoise = getBlueNoiseOffset(uv) - 0.5;\nvec2 circNoise = vec2(cos(blueNoise), sin(blueNoise));\nfloat brightnessScale = (1. - (luminance + 0.25));\nvec2 offset = circNoise * 0.05 * pow(brightnessScale, 3.) * distanceInfo * 2.;\nvec4 color = texture(uTexture, uv + offset);\nvec4 bg = texture(uBgTexture, uv);color.rgb = bg.rgb + (color.rgb * 2.9 * 1.0000 + blueNoise * 0.001);\ncolor.a = bg.a + color.r;\nreturn color;\n}vec4 getColor(vec2 uv) {\nreturn composite(uv);\n}out vec4 fragColor;void main() {\nvec2 uv = vTextureCoord;\nvec4 color = getColor(uv);\nif(2 == 2) {\nfragColor = color;} else {\nfragColor = color;\n}\n}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":false,"passes":[{"prop":"pass","value":1,"downSample":0.5},{"prop":"pass","value":2,"includeBg":true}],"texture":{"src":"https://assets.unicorn.studio/media/blue_noise_med.png","sampler":"uBlueNoise"}},"id":"effect5"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"glyphDither","usesPingPong":false,"texture":{"src":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAbgAAAAoCAYAAACM2+9EAAAQAElEQVR4AeydB7AURROAezBhBHOWh5YU5oAZtZ6ClllRQQwgKIqWmAoDpipzQlBRBFFLjIgBc0atMqJiwgRGMGdRzIr871v/WXrnXdi9t7t33BuKftvT09PT13u3PaGnt42IzPHgbeC/A/474L8D/jtQb98BHFzTZ/L/vQW8BbwFvAW8BerLAt7B1df9zPfT+N68BbwFvAVq2ALewVXx5iy00EJywgknyJQpU+Trr7+W33//PQBwaNTBUy0Vu3TpInfffbe8+eab8t1338mff/4pP/74o7z77rvy0EMPySGHHFIt1YJ+l1122cB+EyZMkGnTpsmvv/4qs2bNCvS98cYb5dBDD5Ulllgi4M3jD/a44oorJA4MGTJEttlmG8nr/i6wwAIRvQ477LDYJjn55JPDtoMHD47dLi7j6aefHsrnnsVt5/Ltt99+oRxwt76l5bPPPjuUH+ceF+Lp06dPS9Uo2j7J96+QbtCyuL+uwrvssktFduzevbsrqmzZO7iyJsqGYdCgQfLLL7/I0KFDZb311pPllltO2rZtGwA4NOrggTcbLQpL3WyzzeSjjz6SyZMny1577SXrrruuLL300rLgggtK+/btpXPnzrLzzjvLddddFzi+ljyUCmtQnnrqqafKF198EdivR48e0qlTJ1lkkUVkscUWC/TlQXLttdcGA4fdd9+9vMAUOBiQcK/iwAUXXCBPP/20/PHHH/L9998LP/oUVCgqYuGFFxat17Bhw4ryuhWnnXZa2PaSSy4JbOzyVFAOm5x00kmh/LPOOiukJ0VwlPYzXnPNNUmbl+VnUGLlV3rlN1O2owoZknz/iumfxf11P86AAQPC+11Mj0L0vn37uqLKlr2DK2ui9BnGjRsXjGDmn3/+ssLhYWRFm7LMKTAcfvjhMmnSJOnYsWMsaTg+HAnOOFaDFjKtuOKK8vHHH8t5550n2KacOAYN9913n4wfP17atGlTjr0q9UsttZQ8+OCDMnHixJrVURsmbTsy87byF110UYsmvrZr1y5so2WGRI/EskDa9zdWpxkx1eYvPqMPWwtiGQ337t27mSr//vuvfPrppwGAuwy0oa1LT7PMss7VV18txpiI2L///jtwKq+++qp88sknQjnC0FRg9NizZ88mLNv/OIGGhoZIJ9iL2dzzzz8vADg0zdSrVy8ZM2aMJtUc3q1bNxk+fHjN6ZW1Qj/99FPYBTPNsJAQYfZum2iZltbSK7/PH374QQqBK7sQDzRkuLytrTxz5syWf+SYEryDi2moNNiY7bCOr2XhLFgGnG+++WS11VYLABwadZqXtsjQtLTwJZdcUm6++eaIuDlz5si5554rPHRWX311YU+uQ4cOsvjii8tVV10V4aWQ5fIL8o855hhZe+21QUN47rnnZPnll5eVV15ZunbtGgA4NOpCxiakf//+wr5dE5rLf+6hMSYYMBgz94o92X9jZv7PP/9EdDn66KODzxIh1nmBB7/9iOwVWjzpFbvaNlqmpbX0usYaawRL9fwGXdADKnC33paR0VI94rYv9v0zZu530Zjm+M8//xy3i4r42Cs0pnm/xkRpo0aNqki+buQdnLZGxvjo0aMjS1B//fWXbL755nLvvfc26xkadfDYSpYOkGHLaV4JcHn//fcjIo877jg544wzZPbs2RE6wSZHHXVUsP+lK3B8OEpNSwsnGIP9AS3v9ttvl6233jrYB9R0cIJiqIOHMoD9brvtNtCqAvtuzz77rOCwmY1qJ4eOl156aVX1y7vzb7/9NuySzx8WEiLsEdsmWqal+Wvrs4B3cDne8z322CPS28CBA+W1116TYv+og0fXuzJ0XUtwHrrMjv6bmUmwRzhixIiSIgkO0A4YZgI+uKYNzHj06J49ljibzvDAa/XZfvvtRe/VWHq1rp9//rmMHDky0j1BPRFCnRe++uqryCdknzVCiFnQztGVGVOEZ6szC3gHl9MN5QGtR5g4hrFjx5btHR54LSMykGXLaV+ZmS2zzDLB7CKObPdBssEGG8RplpinsbEx0uapp54Kji1EiAUKzDbh1VVbbrmlLlYd58iFVoIlVl2ud5w9U/0ZV111VV0UluwZfGlgRq+Z3KVnV6bm9XjrsYB3cDnd64MPPjjS06OPPhoplyq4vK6sUm0rqSNsPW4790HzxhtvxG2aiI/lWt2A2a0ul8JdXldWqbZ51E2dOjXSjQ6WiFTMI4Wkan722WeRJq6D23PPPeXtt9+OwJFHHhlpw/61JrgydZ3HW48FvIPL6V67YffuqL2UGi6vK6tU2yzreBBzZk/3QZSjLqeFs1elZc2YMUMXS+Iub1azzJJKlKhkhqKrCVLQ5XrH3fvjzmB33XXXZibYcccdIzTXKboyI8y+0Gos4B1cTrfadQQffPBB7J5dXldWbEEpM+LMjDGh1C+//DI4RhASUkS++eabiLSNN944Ui5VcHnzjGQrpZet22STTSwaXLMIcQ8E1+if6dOnRzRz9+AKLSlvuOGGkTauU3RlRph9oYYtkK5q3sGla8+i0ggT1pXvvfeeLpbEXV5XVsnGGVQSBMFSpLvUR1hyBt0FIjmDFyD//+M+4P5PLnhxeY2Z65QLNsiZyBk93WVr2z9yz4ZxxEPbgyMqugy+wgorcAnBdYp+BheaplUj3sHldPsJodddcWDalvlBc0CZ0HYAHJqt17zQXFnQsoADDjggSCdFSinOlH344YfCGRlyU66//vphl4S5H3jggfLSSy+FtLQRwuq1TEb1BB1oWiEcHnh1HRGjulxNnDRi++67b0SFu+66K1Ku9wKBQJy5tJ9Tr1AwM3P3eeEzxoi+r9rhIcs9Q0qb1gYMhLFfEnCXy+d1m3kHl9MdJGWU7YofoMW5cuCXHytfSAAcGnUWdBsty9bHvCZi69evX5AQmKjNrbbaShhJa+eKTs8884ystdZacuuttyaSnZT5scceE703ZYwRaKWSKVMHjzHRGVuSIJqkemr+7bbbThgkuMBB18suu0yYBZNGTLchy0NL8jFqWfMSrh0SvwGr+z777GPRIG+nHpwQfGIrtVPUsmx9a7ySeIFgmyRwxx131JWp6tLBMQohA3pc2H///TO/qaXyJnIg2VWgEM3ylJJlefK4GmOCbP0NDQ2Zd8dbDNwD0IxMOdBLElwdJg4OjTp4XOVIJO3Ssigfe+yxcssttzQDHjzU6Vkw/TNgIBcoeGuD3377LfzIOlnADjvsENLJQQpYQmNjo0WDDCO2oGVZmr/Gs4AeKMRrUdtcdengSNh64YUXSlxg9kFEYJa3iodXMfn6ILLlKUSzdaVkWZ40ruxj8DYDCyxFunKJSHz88ceFhMtuXdpl8l3yKiEtl3OBZOYnCIUZHgAOjTrK7oi+FrKZ6M8AzllH3tBQ0yNoFM0I9PedmbftZqONNrKovPjiiwFYAisHFtdOUcuy9f7aOi1Qlw6uklupsyBU0r5cG/2QNSa6ZEaCY7e9SzNmbhsty22XZpl3hrEkaYFMIuT7I5uKHknTJ6/MycPJsXxbbAZmjAnyPqIPwEDg+OOPF/SmDODwWFYFrzagHxGyZIThoe6ed6y2fnn2zwzd9scA1eI6eITlZsDWYTNekUQZnCugZVFurYCtSLWXBMg9W0/28g4up7vpjir1xjk5Fjnrw5cLAIdmVdO80FxZ0PIC9kDuv//+YD+OGbLul70ld9lN16eB41gJ8+fdX8x6iskkBRYBHO4RgZdffrlYk9TpJE5m39ICe266E/ZG1lxzzSCnJ4EWui5t3LWVMSZ2F8ZEeV1ZsQWVYCS4ylbbPWbeS6gHnrxSCLB8XLnHXLVT1LKoa61A2j2eJ0ngkUceycpcVZFblw6Oh8UTTzwhSYA2Wd4B92wTDzbdH4e57UgLXNe5vK4szZsnfsopp8i0adPCLo0xMmzYsLCcJcL74HD8RM/16dNHhgwZIldeeaWQIJpzZaussorwY3UjFI844ogs1YrIJvwdh2xh7733FmZtlonDySRctuUsrwxMtPwk+7gurytLy60UZ7/UtrUzbn3shEEdEbwAuOVlWReclQWugJZF2UPrtUDdOrju3btLEsjawbmRe506dYr9rXN5XVmxBWXA6C5L6n2RDLprJpI9OV7zc9FFFwkzpssvv1xeeeWVgI+3OuuR/ZQpU+T1118P6qrxh6VV/XYDdLj44ovFzlgo5wV6ZlSuzyS85WQVq9c5TY0xwVs3Ghsbxf7jiEohfIsttgjI1ilS0LIoe2i9FqhLB1eLt9P90XXu3Dm2mi6vKwtB1QI3kXGtRGFx/o1jDtouec7edL8aZxlXL/ExC73hhhs0S2Y4+49WeBKnpXm1DCsrjStLylrOSiutFBw/sbRJkyZZVDTesWPHwBlqHV1ZYUOPzFMW0Pe0UsW9g6vUcgnbTZ48OdKCg9ERQonCQQcdFKl1ZUUqcy7opSG65ogG12rDAw88EAk4IRvMCy+8UG21hBB295xbz549m73INQtF9dIiy476vFmx/uCB19ZrGZaWxpXlXC2HVYv27duHJB2Ao3EiZVmSDhmbEFdWE8n/nwct4CbQrmRw5R1cTjfejYpkhsFracp1D4+77OfKKicjbj0JbAnFTrJkxvvVtHyWDHW5GjhnzxjZ277Z9+KwtS1X+3r++edHXtJqjJE8spe40YU41v9sUfyvy+PKKN4yWY2brce9X+ynWokah+aeHXRlweOhuhZgwHLnnXfK9OnThShwNzNRIe3c87VvvfVWIbaSNO/gSponvUoSEXM+S0tkv0iXC+EuDzKQVYi3JTSiNhkZE7nmLjsWk8sSgvvakmrucaEn+27uw5GlSbsvB08tgPvKI5ah3Zl62nq6EYgEvZTrw+VxZZRrH7eeB5/m3WmnncLirFmzgpmvJTALhmbLmheaKwuah+pagOQLZKXp0KGDsCJAHlt9tMPVjpUDN7jOHdi4bQqVvYMrZJWMaOecc05EMg9iNyWXZqAOHk1zZei6SnEetoMHDw6bs3HPPofeuA8rFTJhwgQhilGR5J577tHFXHHSXw0YMCDS5/XXXy9jxoyJ0GqhQKSsOxgYNWpU8HLPrPRzM8GQJWTQoEFFu6MOHs3gytB1LcHdBNM6Aw1nBV3ZmqZ54XNlQfOQnQXiSCaXrZ794+RKDaSZ7cFjZbM86Wdw1ho1eiWM3Y2A5CHCsiBpxZiSA+DQqNMfhbbI0LQ08JtuukmI8NOyGGERkj169Gjp0qWLEAzB/hqZJQjJp07nAqQtUYrVcibM3Eh/hR4W0IegDluutSvLfyyfWr3IpsPZJVtO+zp16lTRDxnkM4hiyZuzepQBcGjUUbZAW2TYcppXHmBAIZk8HF16sf1UZAAufxpl9vq6du0qhcCYuWcFjTEFeWjH8ZU0dIkjg5UL7mES0APdOH0k4Rk3blyEnTOqbGnwG8UuJJgnbSLnQ3UELY1weFyTgp/BJbVYC/m33XZbcVNeTmhlmQAAA7BJREFUsSzIoWl7Xgocmu6KNqXyU2repDgPBL5s7gHZtm3bysCBA4WgFoIL0IHX1pAGi+wmuh/OJpGUWdPywFnm4O0G7sztnXfeiWSbz0OXpH0wC3F/uGSP4ceeVFZc/kIOlD0swvBxtgA4NFfm8OHDXVKqZR1dqgU//PDDuhjgxZZKi8kIGrXwD2/5YO+oEBhjQunGGCnEA02fGw0bZISwdMsgOQmwVcFAKwuVOPM5w3lRMVHX5GYlMIjocNImujNyBvbuSlZc/byDi2uplPh48JKpJPa5u6Z+4aVNVqPnpi6Ew+OEZvMjpJwEeFCzrMmsLkm7lvIymyQknPfTaVnMSNdZZ53Ivo2uryW8X79+oh/Kxhhh6TcrHckAQ+7QJPJxejwkyYiRpF1SXgZJhdqQsMGlF6LBU0wGdbUA5Zb9a0FH9taz0GP27NnCb3bmzJmxxbNqwHlm2sZupBi9g1PGyAslRxw59p588snIK2Dc/plZwQMvbdz6tMtENzEL22233YRZUTn5BLyQKYTN4ErWx8vJL1Xf0NAQzCz1aBN7MfPo27dvqaa51cV52BIw4e6rbrrpppLlLI5oWRxWnAEJPMwERo4cmbnddOCI7YyHIQM8W7ZXaNTZsr0WkmHr/LX6FsBhMWsbMWJEEE1ZTCNWi5hNEkXu7lUXa1OI7h1cIavkQONGd+vWLchiQaopliXHjh0rY5sAHBpLhPDAm4NKYRcs/5BTki9ijx495Mwzz5Tx48cH73wjMTBOEN1YM88jvD1UTCFEyrEnaIwJzrsZY4IADfbipEr/OPphzFx9Jk6cGEsTZkbGzG1njBH2IWI1Ls1UtBaH1a5dO2Fwwp4qe7u8yQAAh0YdPHkMrlCUox3GRO2g3xIAjwbqjInyI0PzpIlz5s6YaH/GJCsjI02dtCz3+2dMMt2M+Y+fQY2WmzbOQJr9crY5eL6R8o+lSRIeMPBi9YWZ7oknnlhyAhBHL+/g4lgpQx5uNqmmuMn9+/cXABwadRl2XVY0Of2IiuRgcu/evYXD6UOHDg32FxhBlxXgGWreAiwv2zRnvXr1EoCUZ9Coq/kP4BWcZy3AM4QVKgb0PFv6NS3XM/BiGyetD+UdXFqW9HK8BbwFvAXqyQJ18Fm8g6uDm+g/greAt4C3gLdAcwt4B9fcJp7iLeAt4C3gLVAHFvAOrmo30XfsLeAt4C3gLZClBbyDy9K6Xra3gLeAt4C3QNUs4B1c1UzvO/YWqNwCvqW3gLdAeQv8DwAA//9EDG0KAAAABklEQVQDAC9Kui+Gxad7AAAAAElFTkSuQmCC","sampler":"uCustomTexture"},"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec3 vVertexPosition;\nin vec2 vTextureCoord;\nuniform sampler2D uTexture;\nuniform sampler2D uSprite;\nuniform sampler2D uCustomTexture;uniform vec2 uMousePos;\nuniform vec2 uResolution;\nvec3 blend (int blendMode, vec3 src, vec3 dst) {\nreturn vec3((src.x <= 0.5) ? (dst.x - (1.0 - 2.0 * src.x) * dst.x * (1.0 - dst.x)) : (((src.x > 0.5) && (dst.x <= 0.25)) ? (dst.x + (2.0 * src.x - 1.0) * (4.0 * dst.x * (4.0 * dst.x + 1.0) * (dst.x - 1.0) + 7.0 * dst.x)) : (dst.x + (2.0 * src.x - 1.0) * (sqrt(dst.x) - dst.x))), (src.y <= 0.5) ? (dst.y - (1.0 - 2.0 * src.y) * dst.y * (1.0 - dst.y)) : (((src.y > 0.5) && (dst.y <= 0.25)) ? (dst.y + (2.0 * src.y - 1.0) * (4.0 * dst.y * (4.0 * dst.y + 1.0) * (dst.y - 1.0) + 7.0 * dst.y)) : (dst.y + (2.0 * src.y - 1.0) * (sqrt(dst.y) - dst.y))), (src.z <= 0.5) ? (dst.z - (1.0 - 2.0 * src.z) * dst.z * (1.0 - dst.z)) : (((src.z > 0.5) && (dst.z <= 0.25)) ? (dst.z + (2.0 * src.z - 1.0) * (4.0 * dst.z * (4.0 * dst.z + 1.0) * (dst.z - 1.0) + 7.0 * dst.z)) : (dst.z + (2.0 * src.z - 1.0) * (sqrt(dst.z) - dst.z))));\n}out vec4 fragColor;void main() {\nvec2 uv = vTextureCoord;\nvec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nfloat aspectRatio = uResolution.x / uResolution.y;\nfloat aspectCorrection = mix(aspectRatio, 1./aspectRatio, 0.5);float gridSize = mix(0.05, 0.005, 0.0000);float baseGrid = 1.0 / gridSize;\nvec2 cellSize = vec2(1.0/(baseGrid * aspectRatio), 1.0/baseGrid) * aspectCorrection;\nvec2 offsetUv = uv - pos;\nvec2 cell = floor(offsetUv / cellSize);\nvec2 cellCenter = (cell + 0.5) * cellSize;\nvec2 pixelatedCoord = cellCenter + pos;\nvec4 bg = texture(uTexture, vTextureCoord);\nvec4 color = texture(uTexture, pixelatedCoord);float luminance = dot(color.rgb, vec3(0.2126, 0.7152, 0.0722));\nluminance = mix(luminance, 1.0 - luminance, float(0));\nfloat gamma = pow(mix(0.2, 2.2, 0.0000), 2.2);ivec2 customTextureSize = textureSize(uCustomTexture, 0);\nivec2 spriteTextureSize = textureSize(uSprite, 0);\nfloat selectedWidth = mix(float(spriteTextureSize.x), float(customTextureSize.x), float(6 == 6));\nfloat GLYPH_HEIGHT = mix(float(spriteTextureSize.y), float(customTextureSize.y), float(6 == 6));\nfloat scaleFactor = gridSize / GLYPH_HEIGHT;\nfloat numSprites = max(1.0, selectedWidth / GLYPH_HEIGHT);\nfloat numGlyphRows = 1.0;float spriteIndex = clamp(floor(luminance * numSprites), 0.0, numSprites - 1.0);\nfloat spriteIndexWithGamma = clamp(floor(luminance * numSprites * gamma), 0.0, numSprites - 1.0);\nfloat phaseOffset = floor(0.0000 * numSprites + 0.5);\nspriteIndexWithGamma = mod(spriteIndexWithGamma + phaseOffset, numSprites);\nfloat glyphIndex = 0.0;float normalizedSpriteSizeX = 1.0 / numSprites;\nfloat normalizedSpriteSizeY = 1.0 / numGlyphRows;float spriteX = (spriteIndexWithGamma * normalizedSpriteSizeX);vec2 spriteSheetUV = vec2(spriteX, glyphIndex / numGlyphRows);vec2 spriteSize = vec2(GLYPH_HEIGHT / aspectRatio, GLYPH_HEIGHT) * scaleFactor * aspectCorrection;\nvec2 localOffset = mod(uv - pos, spriteSize) / spriteSize;float inset = 0.5 / GLYPH_HEIGHT;\nlocalOffset = clamp(localOffset, inset, 1.0 - inset);spriteSheetUV += vec2(localOffset.x * normalizedSpriteSizeX, localOffset.y * normalizedSpriteSizeY);vec4 spriteColor = vec4(0.0);spriteColor = texture(uCustomTexture, spriteSheetUV);\nfloat alpha = smoothstep(0.0, 1.0, spriteColor.r);vec3 cc = (color.rgb - spriteIndex * 0.04) * 1.4;\nvec3 col = cc;vec3 dithered = mix(\nmix(vec3(0.0), vec3(1.0), float(0)),\ncol,\nalpha\n);\ncolor.rgb = mix(bg.rgb, dithered, 1.0000);\ncolor.a = mix(1.0000, alpha, ceil(alpha));\nvec3 blended = blend(12, dithered, bg.rgb);\ncolor.rgb = mix(bg.rgb, blended, 1.0000);\nfragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":false,"texture":{"src":"","sampler":"uSprite"}},"id":"effect6"},{"breakpoints":[],"visible":true,"locked":true,"aspectRatio":21.428571428571427,"layerName":"","userDownsample":1,"isElement":true,"opacity":1,"effects":[],"displace":0,"trackMouse":0,"anchorPoint":"center","mouseMomentum":0,"blendMode":"NORMAL","bgDisplace":0,"mask":0,"maskBackground":{"type":"Vec3","_x":0,"_y":0,"_z":0},"maskAlpha":0,"maskDepth":0,"dispersion":0,"axisTilt":0,"states":{"appear":[],"scroll":[],"hover":[]},"layerType":"image","imageLoaded":false,"width":273.2142857142857,"widthMode":"fixed","height":12.750000000000002,"heightMode":"auto","left":0.5,"leftMode":"relative","top":0.4973611111111111,"topMode":"relative","rotation":0,"trackAxes":"xy","fitToCanvas":0,"exposure":0,"saturation":1,"contrast":1,"src":"https://assets.unicorn.studio/images/FqmFlgX22DYYksu4G0pmfL7UiNX2/Asset%201_v25.svg","naturalWidth":300,"naturalHeight":14,"compiledFragmentShaders":["#version 300 es\nprecision highp float;\nin vec2 vTextureCoord;\nin vec3 vVertexPosition;uniform vec2 uMousePos;\nuniform sampler2D uBgTexture;\nuniform sampler2D uTexture;\nuniform int uSampleBg;const float STEPS = 24.0;\nconst float PI = 3.1415926;out vec4 fragColor;vec4 getNormalOutput(vec4 color, vec4 background) {\ncolor = mix(background, color + background * (1.0 - color.a), 1.0000);\nreturn color;\n}vec4 getOutputByMode(vec4 color, vec4 background) {\nreturn getNormalOutput(color, background);\n}void main() {\nvec2 uv = vTextureCoord;\nvec2 pos = mix(vec2(0), (uMousePos - 0.5), 0.0000);uv -= pos;vec4 background = vec4(0);\nif(uSampleBg == 1) {\nbackground = texture(uBgTexture, vTextureCoord);\n}\nvec4 color = texture(uTexture, uv);color.rgb = clamp(color.rgb, 0.0, 1.0) * color.a;vec4 col = getOutputByMode(color, background);fragColor = col;\n}"],"compiledVertexShaders":["#version 300 es\nprecision highp float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;\nuniform vec2 uMousePos;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\nfloat angleX = uMousePos.y * 0.5 - 0.25;\nfloat angleY = (1.-uMousePos.x) * 0.5 - 0.25;mat4 rotateX = mat4(1.0, 0.0, 0.0, 0.0,\n0.0, cos(angleX), -sin(angleX), 0.0,\n0.0, sin(angleX), cos(angleX), 0.0,\n0.0, 0.0, 0.0, 1.0);\nmat4 rotateY = mat4(cos(angleY), 0.0, sin(angleY), 0.0,\n0.0, 1.0, 0.0, 0.0,\n-sin(angleY), 0.0, cos(angleY), 0.0,\n0.0, 0.0, 0.0, 1.0);mat4 rotationMatrix = rotateX * rotateY;\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvVertexPosition = (rotationMatrix * vec4(aVertexPosition, 1.0)).xyz;\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"uniforms":{}},"id":"image"}],"options":{"name":"Copy of Glow (4)","fps":60,"dpi":1.5,"scale":1,"includeLogo":false,"isProduction":false},"version":"1.5.2","id":"XcJbuXEPHhvMW1Xgiili","modules":{"model_renderer":{"type":"cdn-import","url":"https://cdn.jsdelivr.net/gh/hiunicornstudio/unicornstudio.js@v1.5.2/extensions/model-renderer.js","version":"v1.5.2"}}}