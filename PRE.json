{"history":[{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":0.25,"layerType":"effect","type":"gradient","usesPingPong":false,"speed":0.25,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec2 vTextureCoord;uniform vec2 uMousePos;vec3 getColor(int index) {\nswitch(index) {\ncase 0: return vec3(0, 0, 0);\ncase 1: return vec3(0, 0, 0);\ncase 2: return vec3(0, 0, 0);\ncase 3: return vec3(0, 0, 0);\ncase 4: return vec3(0, 0, 0);\ncase 5: return vec3(0, 0, 0);\ncase 6: return vec3(0, 0, 0);\ncase 7: return vec3(0, 0, 0);\ncase 8: return vec3(0, 0, 0);\ncase 9: return vec3(0, 0, 0);\ncase 10: return vec3(0, 0, 0);\ncase 11: return vec3(0, 0, 0);\ncase 12: return vec3(0, 0, 0);\ncase 13: return vec3(0, 0, 0);\ncase 14: return vec3(0, 0, 0);\ncase 15: return vec3(0, 0, 0);\ndefault: return vec3(0.0);\n}\n}const float PI = 3.14159265;vec2 rotate(vec2 coord, float angle) {\nfloat s = sin(angle);\nfloat c = cos(angle);\nreturn vec2(\ncoord.x * c - coord.y * s,\ncoord.x * s + coord.y * c\n);\n}out vec4 fragColor;vec3 getColor(vec2 uv) {return vec3(0, 0, 0);\n}void main() {vec2 uv = vTextureCoord;\nvec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nuv -= pos;\nuv /= (0.5000*2.);\nuv = rotate(uv, (0.0000 - 0.5) * 2. * PI);\nvec4 color = vec4(getColor(uv), 1.0000);\nfragColor = color;\n}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = aTextureCoord;\n}"],"data":{"downSample":0.5,"depth":false,"uniforms":{},"isBackground":true},"id":"effect"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"beam","usesPingPong":false,"speed":0.55,"trackMouse":0,"trackAxes":"xy","mouseMomentum":1,"texture":false,"animating":true,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;\nprecision highp int;in vec2 vTextureCoord;uniform sampler2D uTexture;uniform float uTime;uniform vec2 uMousePos;\nuniform vec2 uResolution;\nvec3 blend (int blendMode, vec3 src, vec3 dst) {\nreturn src;\n}uvec2 pcg2d(uvec2 v) {\nv = v * 1664525u + 1013904223u;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nv ^= v >> 16;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nreturn v;\n}float randFibo(vec2 p) {\nuvec2 v = floatBitsToUint(p);\nv = pcg2d(v);\nuint r = v.x ^ v.y;\nreturn float(r) / float(0xffffffffu);\n}vec3 Tonemap_tanh(vec3 x) {\nx = clamp(x, -40.0, 40.0);\nreturn (exp(x) - exp(-x)) / (exp(x) + exp(-x));\n}out vec4 fragColor;const float PI = 3.14159265359;\nconst float TWO_PI = 2.0 * PI;float calculateAngle(vec2 point, vec2 center) {\nvec2 direction = point - center;\nfloat angle = atan(direction.y, direction.x);\nif (angle < 0.0) {\nangle += TWO_PI;\n}\nreturn angle;\n}float luma(vec3 color) {\nreturn dot(color, vec3(0.299, 0.587, 0.114));\n}float angularDifference(float angle1, float angle2) {\nfloat diff = abs(angle1 - angle2);\nif (diff > PI) {\ndiff = TWO_PI - diff;\n}\nreturn diff;\n}float angularFading(float pointAngle, float peakAngle, float fadeAmount) {\nfloat diff = angularDifference(pointAngle, peakAngle);\nreturn 1.04 - smoothstep(0.0, fadeAmount, diff);\n}mat2 rot(float a) {\nreturn mat2(cos(a),-sin(a),sin(a),cos(a));\n}vec3 drawRing(vec2 uv, vec2 center, float scale, float angle) {\nuv.x *= uResolution.x/uResolution.y;\ncenter.x *= uResolution.x/uResolution.y;\nvec2 skew = vec2(0.3400, 1. - 0.3400) * 2.;\nuv = uv * rot(0.2457 * TWO_PI) * skew;\ncenter = center * rot(0.2457 * TWO_PI) * skew;\nfloat ringRadius = scale * 0.5;\nfloat distFromCenter = length(uv - center);\nfloat ringDist = abs(distFromCenter - ringRadius);\nfloat lineRadius = 1.0000 * 0.25;\nfloat brightness = lineRadius / (1.0 - smoothstep(0.2, 0.002, ringDist + 0.02));angle = fract(0.2457 + uTime * 0.01 + 0.4900) * TWO_PI;float pointAngle = calculateAngle(uv, center);\nfloat peakAngle = angle;\nfloat angleFactor = angularFading(pointAngle, peakAngle, PI * 0.5);brightness *= angleFactor;vec3 ringColor = brightness * pow(1. - ringDist, 3.) * vec3(0.058823529411764705, 0.09411764705882353, 0.1411764705882353);\nreturn ringColor;\n}vec3 getBeam(vec2 uv) {\nvec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nreturn drawRing(uv, pos, 0.7100, 0.2457);\n}void main() {\nvec2 uv = vTextureCoord;\nvec4 bg = texture(uTexture, uv);vec3 beam = getBeam(uv);\nfloat dither = (randFibo(gl_FragCoord.xy) - 0.5) / 255.0;vec3 blended = blend(0, Tonemap_tanh(beam), bg.rgb);\nvec3 result = mix(bg.rgb, blended, 5.0000);\nresult += dither;vec4 color = vec4(result, max(bg.a, luma(beam)));\nfragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"effect1"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"stretch","usesPingPong":false,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision mediump float;\nin vec3 vVertexPosition;\nin vec2 vTextureCoord;\nuniform sampler2D uTexture;\nuniform vec2 uMousePos;\nuniform vec2 uResolution;\nfloat ease (int easingFunc, float t) {\nreturn t == 0.0 ? 0.0 : pow(2.0, 10.0 * (t - 1.0));\n}out vec4 fragColor;vec2 rotate(vec2 v, float angle) {\nfloat c = cos(angle);\nfloat s = sin(angle);\nreturn vec2(v.x * c - v.y * s, v.x * s + v.y * c);\n}vec3 chromatic_aberration(vec3 color, vec2 uv, float amount) {\nvec2 offset = normalize(vTextureCoord - 0.5) * amount / vec2(uResolution.x/uResolution.y, 1);\nvec4 left = texture(uTexture, uv - offset);\nvec4 right = texture(uTexture, uv + offset);color.r = left.r;\ncolor.b = right.b;return color;\n}void main() {\nvec2 uv = vTextureCoord;\nfloat angle = (0.9990 - 0.25) * -6.28318530718;\nfloat stretchX = vec2(0, 1).x * 4. * 1.0000;\nfloat stretchY = vec2(0, 1).y * 4. * 1.0000;vec2 pos = vec2(0.5008710801393729, 1.0473383662408053) + (uMousePos - 0.5) * 0.0000;\nvec2 offset = uv - pos;\nvec2 rotatedOffset = rotate(offset, -angle);\nvec2 stretchedOffset = rotatedOffset;\nif (1 == 1) {\nif (rotatedOffset.x > 0.0) {\nfloat stretchIntensity = rotatedOffset.x;\nfloat easedIntensity = ease(16, stretchIntensity);\nstretchedOffset.x = rotatedOffset.x / (1.0 + stretchX * easedIntensity);\nstretchedOffset.y = rotatedOffset.y / (1.0 + stretchY * easedIntensity * easedIntensity);\n}\n}\nelse if (1 == 2) {\nfloat stretchIntensity = abs(rotatedOffset.x);\nfloat easedIntensity = ease(16, stretchIntensity);\nstretchedOffset.x = sign(rotatedOffset.x) * stretchIntensity / (1.0 + stretchX * easedIntensity);\nstretchedOffset.y = rotatedOffset.y / (1.0 + stretchY * easedIntensity * easedIntensity);\n}\nvec2 finalOffset = rotate(stretchedOffset, angle);\nvec2 st = pos + finalOffset;\nvec4 color = texture(uTexture, st);color.rgb = chromatic_aberration(color.rgb, st, length(st - uv) * 0.05 * 0.0000);\nfragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"effect2"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"progressiveBlur","usesPingPong":false,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;\nprecision highp int;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uTexture;\nuniform vec2 uMousePos;\nuniform vec2 uResolution;\nuvec2 pcg2d(uvec2 v) {\nv = v * 1664525u + 1013904223u;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nv ^= v >> 16;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nreturn v;\n}float randFibo(vec2 p) {\nuvec2 v = floatBitsToUint(p);\nv = pcg2d(v);\nuint r = v.x ^ v.y;\nreturn float(r) / float(0xffffffffu);\n}out vec4 fragColor;const float PI = 3.141592;mat2 rot(float a) {\nreturn mat2(cos(a),-sin(a),sin(a),cos(a));\n}float easeInOutQuad(float t) {\nreturn t < 0.5 ? 2.0 * t * t : -1.0 + (4.0 - 2.0 * t) * t;\n}const int kernelSize = 36;\nfloat getGaussianWeight(int index) {\nswitch(index) {\ncase 0: return 0.00094768;\ncase 1: return 0.00151965;\ncase 2: return 0.00237008;\ncase 3: return 0.00359517;\ncase 4: return 0.0053041;\ncase 5: return 0.00761097;\ncase 6: return 0.01062197;\ncase 7: return 0.01441804;\ncase 8: return 0.01903459;\ncase 9: return 0.0244409;\ncase 10: return 0.03052299;\ncase 11: return 0.03707432;\ncase 12: return 0.04379813;\ncase 13: return 0.05032389;\ncase 14: return 0.05623791;\ncase 15: return 0.06112521;\ncase 16: return 0.06461716;\ncase 17: return 0.06643724;\ncase 18: return 0.06643724;\ncase 19: return 0.06461716;\ncase 20: return 0.06112521;\ncase 21: return 0.05623791;\ncase 22: return 0.05032389;\ncase 23: return 0.04379813;\ncase 24: return 0.03707432;\ncase 25: return 0.03052299;\ncase 26: return 0.0244409;\ncase 27: return 0.01903459;\ncase 28: return 0.01441804;\ncase 29: return 0.01062197;\ncase 30: return 0.00761097;\ncase 31: return 0.0053041;\ncase 32: return 0.00359517;\ncase 33: return 0.00237008;\ncase 34: return 0.00151965;\ncase 35: return 0.00094768;\ndefault: return 0.0;\n}\n}vec4 directionalBlur(vec2 uv, bool isVertical) {\nvec4 color = vec4(0.0);\nvec2 pos = vec2(0.5, 0.7) + mix(vec2(0), (uMousePos-0.5), 0.0000);vec2 st = uv * rot(0.5000 * 2. * PI);\npos *= rot(0.5000 * 2. * PI);float dist = easeInOutQuad(pos.y - st.y);\nfloat jawn = st.y < pos.y ? 1. : 0.;float amount = 0.7500 * 6. * dist * jawn;if (amount < 0.0001) {\nreturn texture(uTexture, uv);\n}\ncolor += texture(uTexture, uv) * 0.00094768;vec2 direction = isVertical ? vec2(0, uResolution.x/uResolution.y) : vec2(1, 0);\nfor (int i = 0; i < kernelSize; i++) {\nfloat x = float(i - kernelSize / 2) * amount;\nvec2 offset = vec2(x * 0.001) * direction;\ncolor += texture(uTexture, uv + offset) * getGaussianWeight(i);\n}float dither = (randFibo(gl_FragCoord.xy) - 0.5) / 255.0;\ncolor.rgb += dither;return color;\n}vec4 getColor(vec2 uv) {\nreturn directionalBlur(uv, false);\n}void main() {\nvec2 uv = vTextureCoord;\nvec4 color = getColor(uv);\nfragColor = color;}","#version 300 es\nprecision highp float;\nprecision highp int;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uTexture;\nuniform vec2 uMousePos;\nuniform vec2 uResolution;\nuvec2 pcg2d(uvec2 v) {\nv = v * 1664525u + 1013904223u;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nv ^= v >> 16;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nreturn v;\n}float randFibo(vec2 p) {\nuvec2 v = floatBitsToUint(p);\nv = pcg2d(v);\nuint r = v.x ^ v.y;\nreturn float(r) / float(0xffffffffu);\n}out vec4 fragColor;const float PI = 3.141592;mat2 rot(float a) {\nreturn mat2(cos(a),-sin(a),sin(a),cos(a));\n}float easeInOutQuad(float t) {\nreturn t < 0.5 ? 2.0 * t * t : -1.0 + (4.0 - 2.0 * t) * t;\n}const int kernelSize = 36;\nfloat getGaussianWeight(int index) {\nswitch(index) {\ncase 0: return 0.00094768;\ncase 1: return 0.00151965;\ncase 2: return 0.00237008;\ncase 3: return 0.00359517;\ncase 4: return 0.0053041;\ncase 5: return 0.00761097;\ncase 6: return 0.01062197;\ncase 7: return 0.01441804;\ncase 8: return 0.01903459;\ncase 9: return 0.0244409;\ncase 10: return 0.03052299;\ncase 11: return 0.03707432;\ncase 12: return 0.04379813;\ncase 13: return 0.05032389;\ncase 14: return 0.05623791;\ncase 15: return 0.06112521;\ncase 16: return 0.06461716;\ncase 17: return 0.06643724;\ncase 18: return 0.06643724;\ncase 19: return 0.06461716;\ncase 20: return 0.06112521;\ncase 21: return 0.05623791;\ncase 22: return 0.05032389;\ncase 23: return 0.04379813;\ncase 24: return 0.03707432;\ncase 25: return 0.03052299;\ncase 26: return 0.0244409;\ncase 27: return 0.01903459;\ncase 28: return 0.01441804;\ncase 29: return 0.01062197;\ncase 30: return 0.00761097;\ncase 31: return 0.0053041;\ncase 32: return 0.00359517;\ncase 33: return 0.00237008;\ncase 34: return 0.00151965;\ncase 35: return 0.00094768;\ndefault: return 0.0;\n}\n}vec4 directionalBlur(vec2 uv, bool isVertical) {\nvec4 color = vec4(0.0);\nvec2 pos = vec2(0.5, 0.7) + mix(vec2(0), (uMousePos-0.5), 0.0000);vec2 st = uv * rot(0.5000 * 2. * PI);\npos *= rot(0.5000 * 2. * PI);float dist = easeInOutQuad(pos.y - st.y);\nfloat jawn = st.y < pos.y ? 1. : 0.;float amount = 0.7500 * 6. * dist * jawn;if (amount < 0.0001) {\nreturn texture(uTexture, uv);\n}\ncolor += texture(uTexture, uv) * 0.00094768;vec2 direction = isVertical ? vec2(0, uResolution.x/uResolution.y) : vec2(1, 0);\nfor (int i = 0; i < kernelSize; i++) {\nfloat x = float(i - kernelSize / 2) * amount;\nvec2 offset = vec2(x * 0.001) * direction;\ncolor += texture(uTexture, uv + offset) * getGaussianWeight(i);\n}float dither = (randFibo(gl_FragCoord.xy) - 0.5) / 255.0;\ncolor.rgb += dither;return color;\n}vec4 getColor(vec2 uv) {\nreturn directionalBlur(uv, false);\n}void main() {\nvec2 uv = vTextureCoord;\nvec4 color = getColor(uv);\nfragColor = color;}","#version 300 es\nprecision highp float;\nprecision highp int;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uTexture;\nuniform vec2 uMousePos;\nuniform vec2 uResolution;\nuvec2 pcg2d(uvec2 v) {\nv = v * 1664525u + 1013904223u;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nv ^= v >> 16;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nreturn v;\n}float randFibo(vec2 p) {\nuvec2 v = floatBitsToUint(p);\nv = pcg2d(v);\nuint r = v.x ^ v.y;\nreturn float(r) / float(0xffffffffu);\n}out vec4 fragColor;const float PI = 3.141592;mat2 rot(float a) {\nreturn mat2(cos(a),-sin(a),sin(a),cos(a));\n}float easeInOutQuad(float t) {\nreturn t < 0.5 ? 2.0 * t * t : -1.0 + (4.0 - 2.0 * t) * t;\n}const int kernelSize = 36;\nfloat getGaussianWeight(int index) {\nswitch(index) {\ncase 0: return 0.00094768;\ncase 1: return 0.00151965;\ncase 2: return 0.00237008;\ncase 3: return 0.00359517;\ncase 4: return 0.0053041;\ncase 5: return 0.00761097;\ncase 6: return 0.01062197;\ncase 7: return 0.01441804;\ncase 8: return 0.01903459;\ncase 9: return 0.0244409;\ncase 10: return 0.03052299;\ncase 11: return 0.03707432;\ncase 12: return 0.04379813;\ncase 13: return 0.05032389;\ncase 14: return 0.05623791;\ncase 15: return 0.06112521;\ncase 16: return 0.06461716;\ncase 17: return 0.06643724;\ncase 18: return 0.06643724;\ncase 19: return 0.06461716;\ncase 20: return 0.06112521;\ncase 21: return 0.05623791;\ncase 22: return 0.05032389;\ncase 23: return 0.04379813;\ncase 24: return 0.03707432;\ncase 25: return 0.03052299;\ncase 26: return 0.0244409;\ncase 27: return 0.01903459;\ncase 28: return 0.01441804;\ncase 29: return 0.01062197;\ncase 30: return 0.00761097;\ncase 31: return 0.0053041;\ncase 32: return 0.00359517;\ncase 33: return 0.00237008;\ncase 34: return 0.00151965;\ncase 35: return 0.00094768;\ndefault: return 0.0;\n}\n}vec4 directionalBlur(vec2 uv, bool isVertical) {\nvec4 color = vec4(0.0);\nvec2 pos = vec2(0.5, 0.7) + mix(vec2(0), (uMousePos-0.5), 0.0000);vec2 st = uv * rot(0.5000 * 2. * PI);\npos *= rot(0.5000 * 2. * PI);float dist = easeInOutQuad(pos.y - st.y);\nfloat jawn = st.y < pos.y ? 1. : 0.;float amount = 0.7500 * 6. * dist * jawn;if (amount < 0.0001) {\nreturn texture(uTexture, uv);\n}\ncolor += texture(uTexture, uv) * 0.00094768;vec2 direction = isVertical ? vec2(0, uResolution.x/uResolution.y) : vec2(1, 0);\nfor (int i = 0; i < kernelSize; i++) {\nfloat x = float(i - kernelSize / 2) * amount;\nvec2 offset = vec2(x * 0.001) * direction;\ncolor += texture(uTexture, uv + offset) * getGaussianWeight(i);\n}float dither = (randFibo(gl_FragCoord.xy) - 0.5) / 255.0;\ncolor.rgb += dither;return color;\n}vec4 getColor(vec2 uv) {\nreturn directionalBlur(uv, true);\n}void main() {\nvec2 uv = vTextureCoord;\nvec4 color = getColor(uv);\nfragColor = color;}","#version 300 es\nprecision highp float;\nprecision highp int;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uTexture;\nuniform vec2 uMousePos;\nuniform vec2 uResolution;out vec4 fragColor;const float PI = 3.141592;mat2 rot(float a) {\nreturn mat2(cos(a),-sin(a),sin(a),cos(a));\n}float easeInOutQuad(float t) {\nreturn t < 0.5 ? 2.0 * t * t : -1.0 + (4.0 - 2.0 * t) * t;\n}const int kernelSize = 36;\nfloat getGaussianWeight(int index) {\nswitch(index) {\ncase 0: return 0.00094768;\ncase 1: return 0.00151965;\ncase 2: return 0.00237008;\ncase 3: return 0.00359517;\ncase 4: return 0.0053041;\ncase 5: return 0.00761097;\ncase 6: return 0.01062197;\ncase 7: return 0.01441804;\ncase 8: return 0.01903459;\ncase 9: return 0.0244409;\ncase 10: return 0.03052299;\ncase 11: return 0.03707432;\ncase 12: return 0.04379813;\ncase 13: return 0.05032389;\ncase 14: return 0.05623791;\ncase 15: return 0.06112521;\ncase 16: return 0.06461716;\ncase 17: return 0.06643724;\ncase 18: return 0.06643724;\ncase 19: return 0.06461716;\ncase 20: return 0.06112521;\ncase 21: return 0.05623791;\ncase 22: return 0.05032389;\ncase 23: return 0.04379813;\ncase 24: return 0.03707432;\ncase 25: return 0.03052299;\ncase 26: return 0.0244409;\ncase 27: return 0.01903459;\ncase 28: return 0.01441804;\ncase 29: return 0.01062197;\ncase 30: return 0.00761097;\ncase 31: return 0.0053041;\ncase 32: return 0.00359517;\ncase 33: return 0.00237008;\ncase 34: return 0.00151965;\ncase 35: return 0.00094768;\ndefault: return 0.0;\n}\n}vec4 finalBlur(vec2 uv) {\nvec4 color = vec4(0.0);\nvec2 pos = vec2(0.5, 0.7) + mix(vec2(0), (uMousePos-0.5), 0.0000);vec2 st = uv * rot(0.5000 * 2. * PI);\npos *= rot(0.5000 * 2. * PI);float dist = easeInOutQuad(pos.y - st.y);\nfloat jawn = st.y < pos.y ? 1. : 0.;float amount = 0.7500 * 11. * dist * jawn;if (amount < 0.0001) {\nreturn texture(uTexture, uv);\n}\ncolor += texture(uTexture, uv) * 0.00094768;\nfor (int i = 0; i < kernelSize; i++) {\nfloat x = float(i - kernelSize / 2) * amount;\ncolor += texture(uTexture, uv + vec2(x * 0.001, 0)) * getGaussianWeight(i) * 0.5;\ncolor += texture(uTexture, uv + vec2(0, x * 0.001) * vec2(1, uResolution.x/uResolution.y)) * getGaussianWeight(i) * 0.5;\n}return color;\n}vec4 getColor(vec2 uv) {\nreturn finalBlur(uv);\n}void main() {\nvec2 uv = vTextureCoord;\nvec4 color = getColor(uv);\nfragColor = color;}","#version 300 es\nprecision highp float;\nprecision highp int;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uTexture;\nuniform sampler2D uBgTexture;\nuniform vec2 uMousePos;\nuvec2 pcg2d(uvec2 v) {\nv = v * 1664525u + 1013904223u;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nv ^= v >> 16;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nreturn v;\n}float randFibo(vec2 p) {\nuvec2 v = floatBitsToUint(p);\nv = pcg2d(v);\nuint r = v.x ^ v.y;\nreturn float(r) / float(0xffffffffu);\n}out vec4 fragColor;const float PI = 3.141592;mat2 rot(float a) {\nreturn mat2(cos(a),-sin(a),sin(a),cos(a));\n}float easeInOutQuad(float t) {\nreturn t < 0.5 ? 2.0 * t * t : -1.0 + (4.0 - 2.0 * t) * t;\n}const int kernelSize = 36;vec4 composite(vec2 uv) {\nvec4 bg = texture(uBgTexture, uv);\nvec4 fg = texture(uTexture, uv);\nfloat dither = (randFibo(gl_FragCoord.xy) - 0.5) / 255.0;\nfg.rgb += dither;vec2 pos = vec2(0.5, 0.7) + mix(vec2(0), (uMousePos-0.5), 0.0000);vec2 st = uv * rot(0.5000 * 2. * PI);\npos *= rot(0.5000 * 2. * PI);float dist = easeInOutQuad(pos.y - st.y);\nfloat jawn = st.y < pos.y ? 1. : 0.;float m = 0.7500 * 11. * dist * jawn;\nreturn mix(fg, bg, smoothstep(0., 1.0, 1. - m));\n}vec4 getColor(vec2 uv) {\nreturn composite(uv);\n}void main() {\nvec2 uv = vTextureCoord;\nvec4 color = getColor(uv);\nfragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"downSample":0.25,"depth":false,"uniforms":{},"isBackground":false,"passes":[{"prop":"pass","value":0,"downSample":0.25},{"prop":"pass","value":1,"downSample":0.5},{"prop":"pass","value":2,"downSample":0.5},{"prop":"pass","value":3,"includeBg":true}]},"id":"effect3"},{"breakpoints":[],"visible":true,"locked":false,"aspectRatio":1,"layerName":"","userDownsample":1,"layerType":"model","isModel":true,"pos":{"type":"Vec3","_x":0.5,"_y":0.63,"_z":0},"modelUrl":"https://assets.unicorn.studio/models/FqmFlgX22DYYksu4G0pmfL7UiNX2/Di-Pietro_Engine_V1-GC-STEP.glb","scale":0.56,"modelRotation":{"type":"Vec3","_x":0.5,"_y":0.2638888888888889,"_z":0},"lightIntensity":1,"ambientLightIntensity":0,"fillLightIntensity":0,"lightColor":"#ffffff","ambientLightColor":"#FFFFFF","fillLightColor":"#FFFFFF","lightPosition":{"type":"Vec3","_x":0.75,"_y":0.75,"_z":0.75},"materialMetalness":0.5,"materialRoughness":0.5,"rotationTracking":0,"lightTracking":0,"animationAxis":{"type":"Vec3","_x":0,"_y":0,"_z":1.18},"refractScale":0.5,"chromAbAmount":0.5,"renderNormals":1,"blendMode":"NORMAL","colorMapUrl":"","colorMapScale":1,"colorMapPosition":{"type":"Vec2","_x":0.5,"_y":0.5},"colorMapIntensity":1,"normalMapUrl":"","normalMapScale":1,"normalMapPosition":{"type":"Vec2","_x":0.5,"_y":0.5},"normalMapIntensity":1,"quality":"high","environmentMapIntensity":0,"environmentMapUrl":"","extrudeDepth":10,"bevelEnabled":false,"bevelThickness":1,"bevelSize":1,"bevelSegments":2,"glassIOR":2.5,"glassThickness":0,"glassRoughness":0,"glassTint":"#ffffff","glassDispersion":0,"contextType":"webgl","trackAxes":"xy","trackMouse":0,"mouseMomentum":0,"states":{"appear":[],"scroll":[],"hover":[]},"animating":true,"opacity":1,"speed":0.36,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec2 vTextureCoord;\nin vec3 vVertexPosition;uniform sampler2D uBgTexture;\nuniform sampler2D uTexture;uniform float uOpacity;\nout vec4 fragColor;void main() {\nvec4 bgColor = texture(uBgTexture, vTextureCoord);\nvec4 fgColor = texture(uTexture, vTextureCoord);\nvec4 color = vec4(1.0, 0.0, 0.0, 1.0);if(uOpacity < 0.001) {\nfragColor = bgColor;\nreturn;\n}color = mix(bgColor, mix(bgColor, fgColor, fgColor.a), uOpacity);fragColor = color;\n}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"uniforms":{}},"moduleRef":"model_renderer","id":"model"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"reflectiveSurface","usesPingPong":false,"texture":false,"animating":false,"mouseMomentum":0,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision mediump float;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uTexture;uniform vec2 uResolution;out vec4 fragColor;const float PI2 = 6.28318530718;vec2 rotatePoint(vec2 point, vec2 center, float angle) {\nvec2 translated = point - center;\nfloat cosAngle = cos(angle);\nfloat sinAngle = sin(angle);\nvec2 rotated = vec2(\ntranslated.x * cosAngle - translated.y * sinAngle,\ntranslated.x * sinAngle + translated.y * cosAngle\n);\nreturn rotated + center;\n}vec2 getRotatedCoord(vec2 coord) {\nfloat aspectRatio = uResolution.x / uResolution.y;\nvec2 correctedCoord = coord;\ncorrectedCoord.x *= aspectRatio;\nvec2 correctedPos = vec2(0.9, 0.42000000000000004);\ncorrectedPos.x *= aspectRatio;\nvec2 rotatedCorrected = rotatePoint(correctedCoord, correctedPos, 0.9990 * PI2);\nvec2 result = rotatedCorrected;\nresult.x /= aspectRatio;\nreturn result;\n}vec2 getInverseRotatedCoord(vec2 coord) {\nfloat aspectRatio = uResolution.x / uResolution.y;\nvec2 correctedCoord = coord;\ncorrectedCoord.x *= aspectRatio;\nvec2 correctedPos = vec2(0.9, 0.42000000000000004);\ncorrectedPos.x *= aspectRatio;\nvec2 rotatedCorrected = rotatePoint(correctedCoord, correctedPos, 0.9990 * -1. * PI2);\nvec2 result = rotatedCorrected;\nresult.x /= aspectRatio;\nreturn result;\n}const int kernelSize = 36;float getGaussianWeight(int index) {\nswitch(index) {\ncase 0: return 0.00094768;\ncase 1: return 0.00151965;\ncase 2: return 0.00237008;\ncase 3: return 0.00359517;\ncase 4: return 0.0053041;\ncase 5: return 0.00761097;\ncase 6: return 0.01062197;\ncase 7: return 0.01441804;\ncase 8: return 0.01903459;\ncase 9: return 0.0244409;\ncase 10: return 0.03052299;\ncase 11: return 0.03707432;\ncase 12: return 0.04379813;\ncase 13: return 0.05032389;\ncase 14: return 0.05623791;\ncase 15: return 0.06112521;\ncase 16: return 0.06461716;\ncase 17: return 0.06643724;\ncase 18: return 0.06643724;\ncase 19: return 0.06461716;\ncase 20: return 0.06112521;\ncase 21: return 0.05623791;\ncase 22: return 0.05032389;\ncase 23: return 0.04379813;\ncase 24: return 0.03707432;\ncase 25: return 0.03052299;\ncase 26: return 0.0244409;\ncase 27: return 0.01903459;\ncase 28: return 0.01441804;\ncase 29: return 0.01062197;\ncase 30: return 0.00761097;\ncase 31: return 0.0053041;\ncase 32: return 0.00359517;\ncase 33: return 0.00237008;\ncase 34: return 0.00151965;\ncase 35: return 0.00094768;\ndefault: return 0.0;\n}\n}vec4 GaussianBlur(sampler2D tex, vec2 uv, vec2 direction) {\nvec4 color = vec4(0.0);\nfloat weightSum = 0.0;vec2 rotatedUV = getRotatedCoord(uv);\nvec2 rotatedPos = vec2(0.9, 0.42000000000000004);\nfloat y = max(0., distance(rotatedUV.y, rotatedPos.y));float radius = 8.;float amount = max(0.25, (0.2200 + 0.1) * radius * y * 4.);\nfloat aspectRatio = uResolution.x/uResolution.y;direction.x /= aspectRatio;color += texture(tex, uv) * getGaussianWeight(0);\nfor (int i = 0; i < kernelSize; i++) {\nfloat x = float(i - kernelSize / 2) * amount;\ncolor += texture(tex, uv + vec2(x/1000.) * direction) * getGaussianWeight(i);\n}\nreturn color;\n}vec4 blurPass(vec2 uv) {\nfloat aspectRatio = uResolution.x / uResolution.y;\nvec2 direction = vec2(0);if (0 % 2 == 1) {\ndirection = vec2(1,0);\ndirection.x *= (1.-0.5000);\n} else {\ndirection = vec2(0,1);\n}vec2 rotatedUV = getRotatedCoord(uv);\nvec2 rotatedPos = vec2(0.9, 0.42000000000000004);\nrotatedUV = mix(rotatedUV, (rotatedUV + vec2(0., rotatedPos.y)) * vec2(1., 0.5), 0.0000 - 0.5);\nuv = getInverseRotatedCoord(rotatedUV);return GaussianBlur(uTexture, uv, direction);\n}vec4 getColor(vec2 uv) {\nreturn blurPass(uv);\n}void main() {\nvec2 uv = vTextureCoord;\nvec4 color = getColor(uv);\nfragColor = color;}","#version 300 es\nprecision mediump float;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uTexture;uniform vec2 uResolution;out vec4 fragColor;const float PI2 = 6.28318530718;vec2 rotatePoint(vec2 point, vec2 center, float angle) {\nvec2 translated = point - center;\nfloat cosAngle = cos(angle);\nfloat sinAngle = sin(angle);\nvec2 rotated = vec2(\ntranslated.x * cosAngle - translated.y * sinAngle,\ntranslated.x * sinAngle + translated.y * cosAngle\n);\nreturn rotated + center;\n}vec2 getRotatedCoord(vec2 coord) {\nfloat aspectRatio = uResolution.x / uResolution.y;\nvec2 correctedCoord = coord;\ncorrectedCoord.x *= aspectRatio;\nvec2 correctedPos = vec2(0.9, 0.42000000000000004);\ncorrectedPos.x *= aspectRatio;\nvec2 rotatedCorrected = rotatePoint(correctedCoord, correctedPos, 0.9990 * PI2);\nvec2 result = rotatedCorrected;\nresult.x /= aspectRatio;\nreturn result;\n}vec2 getInverseRotatedCoord(vec2 coord) {\nfloat aspectRatio = uResolution.x / uResolution.y;\nvec2 correctedCoord = coord;\ncorrectedCoord.x *= aspectRatio;\nvec2 correctedPos = vec2(0.9, 0.42000000000000004);\ncorrectedPos.x *= aspectRatio;\nvec2 rotatedCorrected = rotatePoint(correctedCoord, correctedPos, 0.9990 * -1. * PI2);\nvec2 result = rotatedCorrected;\nresult.x /= aspectRatio;\nreturn result;\n}const int kernelSize = 36;float getGaussianWeight(int index) {\nswitch(index) {\ncase 0: return 0.00094768;\ncase 1: return 0.00151965;\ncase 2: return 0.00237008;\ncase 3: return 0.00359517;\ncase 4: return 0.0053041;\ncase 5: return 0.00761097;\ncase 6: return 0.01062197;\ncase 7: return 0.01441804;\ncase 8: return 0.01903459;\ncase 9: return 0.0244409;\ncase 10: return 0.03052299;\ncase 11: return 0.03707432;\ncase 12: return 0.04379813;\ncase 13: return 0.05032389;\ncase 14: return 0.05623791;\ncase 15: return 0.06112521;\ncase 16: return 0.06461716;\ncase 17: return 0.06643724;\ncase 18: return 0.06643724;\ncase 19: return 0.06461716;\ncase 20: return 0.06112521;\ncase 21: return 0.05623791;\ncase 22: return 0.05032389;\ncase 23: return 0.04379813;\ncase 24: return 0.03707432;\ncase 25: return 0.03052299;\ncase 26: return 0.0244409;\ncase 27: return 0.01903459;\ncase 28: return 0.01441804;\ncase 29: return 0.01062197;\ncase 30: return 0.00761097;\ncase 31: return 0.0053041;\ncase 32: return 0.00359517;\ncase 33: return 0.00237008;\ncase 34: return 0.00151965;\ncase 35: return 0.00094768;\ndefault: return 0.0;\n}\n}vec4 GaussianBlur(sampler2D tex, vec2 uv, vec2 direction) {\nvec4 color = vec4(0.0);\nfloat weightSum = 0.0;vec2 rotatedUV = getRotatedCoord(uv);\nvec2 rotatedPos = vec2(0.9, 0.42000000000000004);\nfloat y = max(0., distance(rotatedUV.y, rotatedPos.y));float radius = 8.;float amount = max(0.25, (0.2200 + 0.1) * radius * y * 4.);\nfloat aspectRatio = uResolution.x/uResolution.y;direction.x /= aspectRatio;color += texture(tex, uv) * getGaussianWeight(0);\nfor (int i = 0; i < kernelSize; i++) {\nfloat x = float(i - kernelSize / 2) * amount;\ncolor += texture(tex, uv + vec2(x/1000.) * direction) * getGaussianWeight(i);\n}\nreturn color;\n}vec4 blurPass(vec2 uv) {\nfloat aspectRatio = uResolution.x / uResolution.y;\nvec2 direction = vec2(0);if (1 % 2 == 1) {\ndirection = vec2(1,0);\ndirection.x *= (1.-0.5000);\n} else {\ndirection = vec2(0,1);\n}vec2 rotatedUV = getRotatedCoord(uv);\nvec2 rotatedPos = vec2(0.9, 0.42000000000000004);\nrotatedUV = mix(rotatedUV, (rotatedUV + vec2(0., rotatedPos.y)) * vec2(1., 0.5), 0.0000 - 0.5);\nuv = getInverseRotatedCoord(rotatedUV);return GaussianBlur(uTexture, uv, direction);\n}vec4 getColor(vec2 uv) {\nreturn blurPass(uv);\n}void main() {\nvec2 uv = vTextureCoord;\nvec4 color = getColor(uv);\nfragColor = color;}","#version 300 es\nprecision mediump float;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uTexture;\nuniform sampler2D uBgTexture;uniform vec2 uResolution;uvec2 pcg2d(uvec2 v) {\nv = v * 1664525u + 1013904223u;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nv ^= v >> 16;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nreturn v;\n}float randFibo(vec2 p) {\nuvec2 v = floatBitsToUint(p);\nv = pcg2d(v);\nuint r = v.x ^ v.y;\nreturn float(r) / float(0xffffffffu);\n}out vec4 fragColor;const float PI2 = 6.28318530718;vec2 rotatePoint(vec2 point, vec2 center, float angle) {\nvec2 translated = point - center;\nfloat cosAngle = cos(angle);\nfloat sinAngle = sin(angle);\nvec2 rotated = vec2(\ntranslated.x * cosAngle - translated.y * sinAngle,\ntranslated.x * sinAngle + translated.y * cosAngle\n);\nreturn rotated + center;\n}vec2 getRotatedCoord(vec2 coord) {\nfloat aspectRatio = uResolution.x / uResolution.y;\nvec2 correctedCoord = coord;\ncorrectedCoord.x *= aspectRatio;\nvec2 correctedPos = vec2(0.9, 0.42000000000000004);\ncorrectedPos.x *= aspectRatio;\nvec2 rotatedCorrected = rotatePoint(correctedCoord, correctedPos, 0.9990 * PI2);\nvec2 result = rotatedCorrected;\nresult.x /= aspectRatio;\nreturn result;\n}vec2 getInverseRotatedCoord(vec2 coord) {\nfloat aspectRatio = uResolution.x / uResolution.y;\nvec2 correctedCoord = coord;\ncorrectedCoord.x *= aspectRatio;\nvec2 correctedPos = vec2(0.9, 0.42000000000000004);\ncorrectedPos.x *= aspectRatio;\nvec2 rotatedCorrected = rotatePoint(correctedCoord, correctedPos, 0.9990 * -1. * PI2);\nvec2 result = rotatedCorrected;\nresult.x /= aspectRatio;\nreturn result;\n}const int kernelSize = 36;float getGaussianWeight(int index) {\nswitch(index) {\ncase 0: return 0.00094768;\ncase 1: return 0.00151965;\ncase 2: return 0.00237008;\ncase 3: return 0.00359517;\ncase 4: return 0.0053041;\ncase 5: return 0.00761097;\ncase 6: return 0.01062197;\ncase 7: return 0.01441804;\ncase 8: return 0.01903459;\ncase 9: return 0.0244409;\ncase 10: return 0.03052299;\ncase 11: return 0.03707432;\ncase 12: return 0.04379813;\ncase 13: return 0.05032389;\ncase 14: return 0.05623791;\ncase 15: return 0.06112521;\ncase 16: return 0.06461716;\ncase 17: return 0.06643724;\ncase 18: return 0.06643724;\ncase 19: return 0.06461716;\ncase 20: return 0.06112521;\ncase 21: return 0.05623791;\ncase 22: return 0.05032389;\ncase 23: return 0.04379813;\ncase 24: return 0.03707432;\ncase 25: return 0.03052299;\ncase 26: return 0.0244409;\ncase 27: return 0.01903459;\ncase 28: return 0.01441804;\ncase 29: return 0.01062197;\ncase 30: return 0.00761097;\ncase 31: return 0.0053041;\ncase 32: return 0.00359517;\ncase 33: return 0.00237008;\ncase 34: return 0.00151965;\ncase 35: return 0.00094768;\ndefault: return 0.0;\n}\n}vec4 GaussianBlur(sampler2D tex, vec2 uv, vec2 direction) {\nvec4 color = vec4(0.0);\nfloat weightSum = 0.0;vec2 rotatedUV = getRotatedCoord(uv);\nvec2 rotatedPos = vec2(0.9, 0.42000000000000004);\nfloat y = max(0., distance(rotatedUV.y, rotatedPos.y));float radius = 8.;float amount = max(0.25, (0.2200 + 0.1) * radius * y * 4.);\nfloat aspectRatio = uResolution.x/uResolution.y;direction.x /= aspectRatio;color += texture(tex, uv) * getGaussianWeight(0);\nfor (int i = 0; i < kernelSize; i++) {\nfloat x = float(i - kernelSize / 2) * amount;\ncolor += texture(tex, uv + vec2(x/1000.) * direction) * getGaussianWeight(i);\n}\nreturn color;\n}vec4 blurPass(vec2 uv) {\nfloat aspectRatio = uResolution.x / uResolution.y;\nvec2 direction = vec2(0);if (2 % 2 == 1) {\ndirection = vec2(1,0);\ndirection.x *= (1.-0.5000);\n} else {\ndirection = vec2(0,1);\n}vec2 rotatedUV = getRotatedCoord(uv);\nvec2 rotatedPos = vec2(0.9, 0.42000000000000004);\nrotatedUV = mix(rotatedUV, (rotatedUV + vec2(0., rotatedPos.y)) * vec2(1., 0.5), 0.0000 - 0.5);\nuv = getInverseRotatedCoord(rotatedUV);return GaussianBlur(uTexture, uv, direction);\n}vec4 reflectAndMix(vec4 originalColor, vec4 blurredColor, float yPos) {\nvec2 rotatedCoord = getRotatedCoord(vTextureCoord);\nfloat reflectedY = yPos - (rotatedCoord.y - yPos);\nreflectedY = clamp(reflectedY, 0., 1.);vec2 rotatedReflectedCoord = vec2(rotatedCoord.x, reflectedY);\nvec2 reflectedCoord = getInverseRotatedCoord(rotatedReflectedCoord);\nreflectedCoord = clamp(reflectedCoord, 0., 1.);vec4 reflectedColor = texture(uTexture, reflectedCoord);reflectedColor.rgb = mix(vec3(0, 0, 0), reflectedColor.rgb, 1.0000);float dither = (randFibo(gl_FragCoord.xy) - 0.5) / 255.0;\nreflectedColor.rgb += dither;return mix(originalColor, reflectedColor, step(rotatedCoord.y, yPos));\n}vec4 compositePass(vec2 uv) {\nvec4 bg = texture(uBgTexture, uv);\nvec4 blur = blurPass(uv);\nreturn reflectAndMix(bg, blur, vec2(0.9, 0.42000000000000004).y);\n}vec4 getColor(vec2 uv) {\nreturn compositePass(uv);\n}void main() {\nvec2 uv = vTextureCoord;\nvec4 color = getColor(uv);\nfragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"downSample":0.25,"depth":false,"uniforms":{},"isBackground":false,"passes":[{"prop":"pass","value":1,"downSample":0.25},{"prop":"pass","value":2,"includeBg":0.5}]},"id":"effect4"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"waterRipple","usesPingPong":true,"speed":0.75,"mouseMomentum":0,"texture":false,"animating":true,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec2 vTextureCoord;\nin vec3 vVertexPosition;uniform sampler2D uPingPongTexture;const float PI = 3.1415926;\nconst float ITERATIONS = 24.0;out vec4 fragColor;vec3 calculateNormal(sampler2D tex, vec2 uv) {\nfloat stengthScale = mix(3., 7., 0.6600);\nfloat stepScale = mix(1., 3., 0.6600);\nfloat strength = mix(1., stengthScale, 0.5000);\nfloat stepSize = mix(1., stepScale, 0.5000);\nfloat step = stepSize / 1080.;\nfloat left = texture(tex, uv + vec2(-step, 0.0)).r;\nfloat right = texture(tex, uv + vec2(step, 0.0)).r;\nfloat top = texture(tex, uv + vec2(0.0, -step)).r;\nfloat bottom = texture(tex, uv + vec2(0.0, step)).r;\nvec3 normal;\nnormal.x = (right - left) * strength;\nnormal.y = -(bottom - top) * strength;\nnormal.z = -1.0;\nreturn normalize(normal);\n}vec4 drawRipple(vec2 uv) {\nvec2 scaled = mix(uv, (uv - 0.5) * 0.5 + 0.5, 0.6600);\nvec3 normal = calculateNormal(uPingPongTexture, scaled);\nreturn vec4(normal, 1.);\n}const vec3 LIGHT_POS = vec3(2.0, 2.0, 3.0);\nconst vec3 VIEW_POS = vec3(0.0, 0.0, 2.0);\nconst float SPECULAR = 2.4;\nconst float SHININESS = 128.0;vec4 getColor(vec2 uv) {\nreturn drawRipple(uv);\n}void main() {\nvec2 uv = vTextureCoord;\nvec4 color = getColor(uv);\nfragColor = color;\n}","#version 300 es\nprecision highp float;in vec2 vTextureCoord;\nin vec3 vVertexPosition;uniform sampler2D uTexture;const float PI = 3.1415926;\nconst float ITERATIONS = 24.0;float getGaussianWeight(int index) {\nswitch(index) {\ncase 0: return 0.7978845608028654;\ncase 1: return 0.795118932516684;\ncase 2: return 0.7868794322038799;\ncase 3: return 0.7733362336056986;\ncase 4: return 0.7547664553859864;\ncase 5: return 0.7315447328280048;\ncase 6: return 0.704130653528599;\ncase 7: return 0.6730536454899063;\ncase 8: return 0.6388960110447045;\ncase 9: return 0.6022748643096089;\ncase 10: return 0.5638237508206051;\ncase 11: return 0.5241747061566029;\ncase 12: return 0.48394144903828673;\ncase 13: return 0.443704309411472;\ncase 14: return 0.40399737110811773;\ncase 15: return 0.36529817077804383;\ncase 16: return 0.3280201493519873;\ncase 17: return 0.29250790855907144;\ncase 18: return 0.2590351913317835;\ncase 19: return 0.2278053882403838;\ncase 20: return 0.19895427758549736;\ncase 21: return 0.17255463765302306;\ncase 22: return 0.1486223271179862;\ncase 23: return 0.12712341303392466;\ndefault: return 0.0;\n}\n}out vec4 fragColor;vec4 blur(vec2 uv, vec2 dir) {\nvec4 color = vec4(0.0);\nfloat total_weight = 0.0;\nvec4 center = texture(uTexture, uv);\nfloat center_weight = getGaussianWeight(0);\ncolor += center * center_weight;\ntotal_weight += center_weight;\nfor (int i = 1; i <= 11; i++) {\nfloat weight = getGaussianWeight(i);\nfloat offset = mix(0.005, 0.015, 0.2500) * float(i)/11.;\nvec4 sample1 = texture(uTexture, uv + offset * dir);\nvec4 sample2 = texture(uTexture, uv - offset * dir);\ncolor += (sample1 + sample2) * weight;\ntotal_weight += 2.0 * weight;\n}return color / total_weight;\n}const vec3 LIGHT_POS = vec3(2.0, 2.0, 3.0);\nconst vec3 VIEW_POS = vec3(0.0, 0.0, 2.0);\nconst float SPECULAR = 2.4;\nconst float SHININESS = 128.0;vec4 getColor(vec2 uv) {\nreturn blur(uv, vec2(1, 0));\n}void main() {\nvec2 uv = vTextureCoord;\nvec4 color = getColor(uv);\nfragColor = color;\n}","#version 300 es\nprecision highp float;in vec2 vTextureCoord;\nin vec3 vVertexPosition;uniform sampler2D uTexture;const float PI = 3.1415926;\nconst float ITERATIONS = 24.0;float getGaussianWeight(int index) {\nswitch(index) {\ncase 0: return 0.7978845608028654;\ncase 1: return 0.795118932516684;\ncase 2: return 0.7868794322038799;\ncase 3: return 0.7733362336056986;\ncase 4: return 0.7547664553859864;\ncase 5: return 0.7315447328280048;\ncase 6: return 0.704130653528599;\ncase 7: return 0.6730536454899063;\ncase 8: return 0.6388960110447045;\ncase 9: return 0.6022748643096089;\ncase 10: return 0.5638237508206051;\ncase 11: return 0.5241747061566029;\ncase 12: return 0.48394144903828673;\ncase 13: return 0.443704309411472;\ncase 14: return 0.40399737110811773;\ncase 15: return 0.36529817077804383;\ncase 16: return 0.3280201493519873;\ncase 17: return 0.29250790855907144;\ncase 18: return 0.2590351913317835;\ncase 19: return 0.2278053882403838;\ncase 20: return 0.19895427758549736;\ncase 21: return 0.17255463765302306;\ncase 22: return 0.1486223271179862;\ncase 23: return 0.12712341303392466;\ndefault: return 0.0;\n}\n}out vec4 fragColor;vec4 blur(vec2 uv, vec2 dir) {\nvec4 color = vec4(0.0);\nfloat total_weight = 0.0;\nvec4 center = texture(uTexture, uv);\nfloat center_weight = getGaussianWeight(0);\ncolor += center * center_weight;\ntotal_weight += center_weight;\nfor (int i = 1; i <= 11; i++) {\nfloat weight = getGaussianWeight(i);\nfloat offset = mix(0.005, 0.015, 0.2500) * float(i)/11.;\nvec4 sample1 = texture(uTexture, uv + offset * dir);\nvec4 sample2 = texture(uTexture, uv - offset * dir);\ncolor += (sample1 + sample2) * weight;\ntotal_weight += 2.0 * weight;\n}return color / total_weight;\n}const vec3 LIGHT_POS = vec3(2.0, 2.0, 3.0);\nconst vec3 VIEW_POS = vec3(0.0, 0.0, 2.0);\nconst float SPECULAR = 2.4;\nconst float SHININESS = 128.0;vec4 getColor(vec2 uv) {\nreturn blur(uv, vec2(0, 1));\n}void main() {\nvec2 uv = vTextureCoord;\nvec4 color = getColor(uv);\nfragColor = color;\n}","#version 300 es\nprecision highp float;in vec2 vTextureCoord;\nin vec3 vVertexPosition;uniform sampler2D uTexture;\nuniform sampler2D uBgTexture;const float PI = 3.1415926;\nconst float ITERATIONS = 24.0;out vec4 fragColor;vec3 chromatic_aberration(vec3 color, vec2 uv) {\nvec2 offset = (uv - vTextureCoord) * (0.2500 * 0.2);\nvec4 left = texture(uBgTexture, uv - offset);\nvec4 right = texture(uBgTexture, uv + offset);color.r = left.r;\ncolor.b = right.b;return color;\n}vec2 calculateRefraction(vec3 normal, float ior) {\nvec3 I = vec3(0.0, 0.0, 1.0);\nfloat ratio = 1.0 / ior;\nvec3 refracted = refract(I, normal, ratio);\nfloat refractionScale = mix(0.2, 0.4, 0.6600);\nfloat refractionAmount = mix(0.01, refractionScale, 0.5000);\nreturn refracted.xy * refractionAmount;\n}const vec3 LIGHT_POS = vec3(2.0, 2.0, 3.0);\nconst vec3 VIEW_POS = vec3(0.0, 0.0, 2.0);\nconst float SPECULAR = 2.4;\nconst float SHININESS = 128.0;vec3 calculateLighting(vec3 normal, vec2 uv) {\nvec3 N = normal;\nvec3 worldPos = vec3(uv * 2.0 - 1.0, 0.0);\nvec3 lightDir = normalize(LIGHT_POS - worldPos);\nvec3 viewDir = normalize(VIEW_POS - worldPos);\nvec3 reflectDir = reflect(-lightDir, N);\nfloat diff = max(dot(N, lightDir), 0.0);\nvec3 diffuse = vec3(diff);\nfloat spec = pow(max(dot(viewDir, reflectDir), 0.0), SHININESS);\nvec3 specular = vec3(spec * SPECULAR);\nreturn diffuse + specular;\n}vec4 getRipple(vec2 uv) {\nvec3 normal = texture(uTexture, uv).rgb;\nvec2 refractionOffset = calculateRefraction(normal, 1.333);\nvec2 refractedUv = uv + refractionOffset;\nvec3 refractedNormal = texture(uTexture, refractedUv).rgb;vec4 refractedColor = texture(uBgTexture, refractedUv);\nrefractedColor.rgb = chromatic_aberration(refractedColor.rgb, refractedUv);vec3 caustics = calculateLighting(refractedNormal, refractedUv);\nfloat causticsShadow = dot(normal, normalize(vec3(2.0, -2.0, 3.0) - vec3(uv * 2.0 - 1.0, 0.0))) + 1.;\nfloat shadowFactor = causticsShadow;\nvec3 lightingFactor = caustics;shadowFactor = mix(1., shadowFactor, 0.6100);\nlightingFactor = mix(vec3(0), lightingFactor * vec3(1, 1, 1), 0.6100);\nvec4 finalColor = vec4(refractedColor.rgb - vec3(1.-shadowFactor) * vec3(1, 1, 1) + lightingFactor, refractedColor.a);\nreturn finalColor;\n}vec4 getColor(vec2 uv) {\nreturn getRipple(uv);\n}void main() {\nvec2 uv = vTextureCoord;\nvec4 color = getColor(uv);\nfragColor = color;\n}","#version 300 es\nprecision highp float;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uPingPongTexture;\nuniform vec2 uPreviousMousePos;uniform vec2 uMousePos;\nuniform vec2 uResolution;const float PI = 3.1415926;\nconst float TWOPI = 6.2831852;out vec4 fragColor;void main() {\nvec2 aspect = vec2(uResolution.x/uResolution.y, 1);\nvec2 texelSize = (1.0 / (vec2(1080) * aspect)) * mix(1., 8., 0.7500);\nvec2 vUv = vTextureCoord;\nvec2 mPos = mix(uMousePos, (uMousePos - 0.5) * 0.5 + 0.5, 0.6600);\nvec2 pmPos = mix(uPreviousMousePos, (uPreviousMousePos - 0.5) * 0.5 + 0.5, 0.6600);float waveSpeed = 1.;\nfloat damping = mix(0.8, 0.999, 0.7500);\nfloat velocityDamping = damping;\nfloat heightDamping = damping;\nfloat time = 0.5;vec4 data = texture(uPingPongTexture, vUv);\nfloat height = data.r;\nfloat velocity = data.g;float laplacian = 0.0;\nfloat totalWeight = 0.0;\nfloat scaleDiff = 0.6600 * 0.25;\nvec2 clampRegionMin = vec2(0.6600 * 0.5 - scaleDiff);\nvec2 clampRegionMax = vec2(1.0 - 0.6600 * 0.5 + scaleDiff);\nvec2 offset = vec2(texelSize.x, 0.0);\nvec2 neighborUv = clamp(vUv + offset, clampRegionMin, clampRegionMax);\nfloat weight = 1.0 - length(offset) / (length(texelSize) * 2.0);\nlaplacian += texture(uPingPongTexture, neighborUv).r * weight;\ntotalWeight += weight;\noffset = vec2(-texelSize.x, 0.0);\nneighborUv = clamp(vUv + offset, clampRegionMin, clampRegionMax);\nweight = 1.0 - length(offset) / (length(texelSize) * 2.0);\nlaplacian += texture(uPingPongTexture, neighborUv).r * weight;\ntotalWeight += weight;\noffset = vec2(0.0, texelSize.y);\nneighborUv = clamp(vUv + offset, clampRegionMin, clampRegionMax);\nweight = 1.0 - length(offset) / (length(texelSize) * 2.0);\nlaplacian += texture(uPingPongTexture, neighborUv).r * weight;\ntotalWeight += weight;\noffset = vec2(0.0, -texelSize.y);\nneighborUv = clamp(vUv + offset, clampRegionMin, clampRegionMax);\nweight = 1.0 - length(offset) / (length(texelSize) * 2.0);\nlaplacian += texture(uPingPongTexture, neighborUv).r * weight;\ntotalWeight += weight;float avgNeighbors = laplacian / totalWeight;\nlaplacian = avgNeighbors - height;velocity += waveSpeed * waveSpeed * laplacian;\nvelocity *= velocityDamping;\nheight += velocity;\nheight *= heightDamping;float mouseSpeed = distance(mPos * aspect, pmPos * aspect);\nfloat dist = distance(vUv * aspect, mPos * aspect);\nfloat radius = 0.025;\nif (dist < radius && mouseSpeed > 0.0001) {\nfloat drop = cos(dist / radius * PI * time);\nfloat intensity = mouseSpeed * 20.;\nheight += drop * intensity;\n}fragColor = vec4(height, velocity, 0.0, 1.0);\n}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = aTextureCoord;\n}","#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = aTextureCoord;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":false,"passes":[{"prop":"pass","value":1,"downSample":0.25},{"prop":"pass","value":2,"downSample":0.25},{"prop":"pass","value":3,"includeBg":true}]},"id":"effect5"},{"breakpoints":[],"visible":true,"locked":false,"aspectRatio":12.5,"layerName":"","userDownsample":1,"isElement":true,"opacity":1,"effects":[],"displace":0,"trackMouse":0,"anchorPoint":"center","mouseMomentum":0,"blendMode":"NORMAL","bgDisplace":0,"mask":0,"maskBackground":{"type":"Vec3","_x":0,"_y":0,"_z":0},"maskAlpha":0,"maskDepth":0,"dispersion":0,"axisTilt":0,"states":{"appear":[],"scroll":[],"hover":[]},"layerType":"image","imageLoaded":false,"width":312.5,"widthMode":"fixed","height":25,"heightMode":"auto","left":0.5,"leftMode":"relative","top":0.86,"topMode":"relative","rotation":0,"trackAxes":"xy","fitToCanvas":0,"exposure":0,"saturation":1,"contrast":1,"src":"https://assets.unicorn.studio/images/FqmFlgX22DYYksu4G0pmfL7UiNX2/Asset%201_v28.svg","naturalWidth":300,"naturalHeight":24,"compiledFragmentShaders":["#version 300 es\nprecision highp float;\nin vec2 vTextureCoord;\nin vec3 vVertexPosition;uniform vec2 uMousePos;\nuniform sampler2D uBgTexture;\nuniform sampler2D uTexture;\nuniform int uSampleBg;const float STEPS = 24.0;\nconst float PI = 3.1415926;out vec4 fragColor;vec4 getNormalOutput(vec4 color, vec4 background) {\ncolor = mix(background, color + background * (1.0 - color.a), 1.0000);\nreturn color;\n}vec4 getOutputByMode(vec4 color, vec4 background) {\nreturn getNormalOutput(color, background);\n}void main() {\nvec2 uv = vTextureCoord;\nvec2 pos = mix(vec2(0), (uMousePos - 0.5), 0.0000);uv -= pos;vec4 background = vec4(0);\nif(uSampleBg == 1) {\nbackground = texture(uBgTexture, vTextureCoord);\n}\nvec4 color = texture(uTexture, uv);color.rgb = clamp(color.rgb, 0.0, 1.0);vec4 col = getOutputByMode(color, background);fragColor = col;\n}"],"compiledVertexShaders":["#version 300 es\nprecision highp float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;\nuniform vec2 uMousePos;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\nfloat angleX = uMousePos.y * 0.5 - 0.25;\nfloat angleY = (1.-uMousePos.x) * 0.5 - 0.25;mat4 rotateX = mat4(1.0, 0.0, 0.0, 0.0,\n0.0, cos(angleX), -sin(angleX), 0.0,\n0.0, sin(angleX), cos(angleX), 0.0,\n0.0, 0.0, 0.0, 1.0);\nmat4 rotateY = mat4(cos(angleY), 0.0, sin(angleY), 0.0,\n0.0, 1.0, 0.0, 0.0,\n-sin(angleY), 0.0, cos(angleY), 0.0,\n0.0, 0.0, 0.0, 1.0);mat4 rotationMatrix = rotateX * rotateY;\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvVertexPosition = (rotationMatrix * vec4(aVertexPosition, 1.0)).xyz;\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"uniforms":{}},"id":"image"}],"options":{"name":"Copy of Falling Cubes (Remix) (2)","fps":60,"dpi":1.5,"scale":1,"includeLogo":false,"isProduction":false},"version":"1.5.2","id":"dadKLTEddUIug9YaXb8l","modules":{"model_renderer":{"type":"cdn-import","url":"https://cdn.jsdelivr.net/gh/hiunicornstudio/unicornstudio.js@v1.5.2/extensions/model-renderer.js","version":"v1.5.2"}}}