{"history":[{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"gradient","usesPingPong":false,"speed":0.5,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec2 vTextureCoord;uniform vec2 uMousePos;vec3 getColor(int index) {\nswitch(index) {\ncase 0: return vec3(0, 0, 0);\ncase 1: return vec3(0, 0, 0);\ncase 2: return vec3(0, 0, 0);\ncase 3: return vec3(0, 0, 0);\ncase 4: return vec3(0, 0, 0);\ncase 5: return vec3(0, 0, 0);\ncase 6: return vec3(0, 0, 0);\ncase 7: return vec3(0, 0, 0);\ncase 8: return vec3(0, 0, 0);\ncase 9: return vec3(0, 0, 0);\ncase 10: return vec3(0, 0, 0);\ncase 11: return vec3(0, 0, 0);\ncase 12: return vec3(0, 0, 0);\ncase 13: return vec3(0, 0, 0);\ncase 14: return vec3(0, 0, 0);\ncase 15: return vec3(0, 0, 0);\ndefault: return vec3(0.0);\n}\n}const float PI = 3.14159265;vec2 rotate(vec2 coord, float angle) {\nfloat s = sin(angle);\nfloat c = cos(angle);\nreturn vec2(\ncoord.x * c - coord.y * s,\ncoord.x * s + coord.y * c\n);\n}out vec4 fragColor;vec3 getColor(vec2 uv) {return vec3(0, 0, 0);\n}void main() {vec2 uv = vTextureCoord;\nvec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nuv -= pos;\nuv /= (0.5000*2.);\nuv = rotate(uv, (0.0000 - 0.5) * 2. * PI);\nvec4 color = vec4(getColor(uv), 1.0000);\nfragColor = color;\n}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = aTextureCoord;\n}"],"data":{"downSample":0.5,"depth":false,"uniforms":{},"isBackground":true},"id":"effect"},{"breakpoints":[],"visible":true,"locked":false,"aspectRatio":1,"layerName":"","userDownsample":1,"isElement":true,"opacity":1,"effects":[],"displace":0,"trackMouse":0,"anchorPoint":"center","mouseMomentum":0,"blendMode":"SCREEN","bgDisplace":0,"mask":0,"maskBackground":{"type":"Vec3","_x":0,"_y":0,"_z":0},"maskAlpha":0,"maskDepth":0,"dispersion":0,"axisTilt":0,"states":{"appear":[],"scroll":[],"hover":[]},"layerType":"image","imageLoaded":false,"width":450,"widthMode":"fixed","height":450,"heightMode":"auto","left":0.5,"leftMode":"relative","top":0.5,"topMode":"relative","rotation":0,"trackAxes":"xy","fitToCanvas":1,"exposure":0,"saturation":1.04,"contrast":1,"src":"https://assets.unicorn.studio/images/FqmFlgX22DYYksu4G0pmfL7UiNX2/9251c672e5420738c8dd3d5089ba2563.jpg","naturalWidth":1024,"naturalHeight":1024,"compiledFragmentShaders":["#version 300 es\nprecision highp float;\nin vec2 vTextureCoord;\nin vec3 vVertexPosition;uniform vec2 uMousePos;\nuniform sampler2D uBgTexture;\nuniform sampler2D uTexture;\nuniform int uSampleBg;vec3 blend (int blendMode, vec3 src, vec3 dst) {\nreturn 1. - (1. - src) * (1. - dst);\n}const float STEPS = 24.0;\nconst float PI = 3.1415926;out vec4 fragColor;vec4 getNormalOutput(vec4 color, vec4 background) {\nvec3 unpremultColor = color.rgb / max(color.a, 0.0001);\nvec3 blendedColor = blend(4, unpremultColor, background.rgb);\ncolor = vec4(blendedColor, 1.0) * (color.a * 1.0000);\ncolor = color + background * (1.0 - color.a);\nreturn color;\n}vec4 getOutputByMode(vec4 color, vec4 background) {\nreturn getNormalOutput(color, background);\n}void main() {\nvec2 uv = vTextureCoord;\nvec2 pos = mix(vec2(0), (uMousePos - 0.5), 0.0000);uv -= pos;vec4 background = vec4(0);\nif(uSampleBg == 1) {\nbackground = texture(uBgTexture, vTextureCoord);\n}\nvec4 color = texture(uTexture, uv);float luminance = dot(color.rgb, vec3(0.299, 0.587, 0.114));\ncolor.rgb = mix(vec3(luminance), color.rgb, 1.0400);color.rgb = clamp(color.rgb, 0.0, 1.0);vec4 col = getOutputByMode(color, background);fragColor = col;\n}"],"compiledVertexShaders":["#version 300 es\nprecision highp float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;\nuniform vec2 uMousePos;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\nfloat angleX = uMousePos.y * 0.5 - 0.25;\nfloat angleY = (1.-uMousePos.x) * 0.5 - 0.25;mat4 rotateX = mat4(1.0, 0.0, 0.0, 0.0,\n0.0, cos(angleX), -sin(angleX), 0.0,\n0.0, sin(angleX), cos(angleX), 0.0,\n0.0, 0.0, 0.0, 1.0);\nmat4 rotateY = mat4(cos(angleY), 0.0, sin(angleY), 0.0,\n0.0, 1.0, 0.0, 0.0,\n-sin(angleY), 0.0, cos(angleY), 0.0,\n0.0, 0.0, 0.0, 1.0);mat4 rotationMatrix = rotateX * rotateY;\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvVertexPosition = (rotationMatrix * vec4(aVertexPosition, 1.0)).xyz;\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"uniforms":{}},"id":"image"},{"breakpoints":[],"visible":true,"locked":false,"aspectRatio":1,"layerName":"","userDownsample":1,"layerType":"model","isModel":true,"pos":{"type":"Vec3","_x":0.5,"_y":0.63,"_z":0},"modelUrl":"https://assets.unicorn.studio/models/FqmFlgX22DYYksu4G0pmfL7UiNX2/hitem3d-v2-v1_v1.glb","scale":0.55,"modelRotation":{"type":"Vec3","_x":0,"_y":0.4388888888888889,"_z":0},"lightIntensity":0.56,"ambientLightIntensity":0,"fillLightIntensity":1,"lightColor":"#ffffff","ambientLightColor":"#FFFFFF","fillLightColor":"#7abbbbDE","lightPosition":{"type":"Vec3","_x":0.544,"_y":0.75,"_z":0.75},"materialMetalness":1,"materialRoughness":1,"rotationTracking":0,"lightTracking":0,"animationAxis":{"type":"Vec3","_x":0,"_y":1.64,"_z":0},"refractScale":0.5,"chromAbAmount":0.5,"renderNormals":0,"blendMode":"NORMAL","colorMapUrl":"https://assets.unicorn.studio/media/materials/black_marble2/black_marble2_color.webp","colorMapScale":1,"colorMapPosition":{"type":"Vec2","_x":0.5,"_y":0.5},"colorMapIntensity":0.4,"normalMapUrl":"https://assets.unicorn.studio/media/materials/black_marble2/black_marble2_normal.webp","normalMapScale":1,"normalMapPosition":{"type":"Vec2","_x":0.5,"_y":0.5},"normalMapIntensity":1,"quality":"high","environmentMapIntensity":0,"environmentMapUrl":"","extrudeDepth":10,"bevelEnabled":false,"bevelThickness":1,"bevelSize":1,"bevelSegments":2,"glassIOR":2.5,"glassThickness":0,"glassRoughness":0.91,"glassTint":"#ffffff","glassDispersion":0.95,"contextType":"webgl","trackAxes":"xy","trackMouse":0,"mouseMomentum":0,"states":{"appear":[],"scroll":[],"hover":[]},"animating":true,"opacity":0.6,"speed":0.32,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec2 vTextureCoord;\nin vec3 vVertexPosition;uniform sampler2D uBgTexture;\nuniform sampler2D uTexture;uniform float uOpacity;\nout vec4 fragColor;void main() {\nvec4 bgColor = texture(uBgTexture, vTextureCoord);\nvec4 fgColor = texture(uTexture, vTextureCoord);\nvec4 color = vec4(1.0, 0.0, 0.0, 1.0);if(uOpacity < 0.001) {\nfragColor = bgColor;\nreturn;\n}color = mix(bgColor, mix(bgColor, fgColor, fgColor.a), uOpacity);fragColor = color;\n}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"uniforms":{}},"moduleRef":"model_renderer","id":"model"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"godrays","usesPingPong":false,"trackMouse":0.52,"trackAxes":"xy","mouseMomentum":1,"texture":false,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;\nprecision highp int;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uTexture;const float MAX_ITERATIONS = 64.;\nconst float PI2 = 6.28318530718;\nconst float EPSILON = 0.0001;\nconst float stepFactor = 0.0098;vec4 getBrightAreas(vec2 uv) {\nvec4 color = texture(uTexture, uv);\nfloat lum = dot(color.rgb, vec3(0.299, 0.587, 0.114));\ncolor = color * smoothstep(0.0000 - 0.1, 0.0000, lum);\nreturn color;\n}vec4 getColor(vec2 uv) {\nreturn getBrightAreas(uv);\n}out vec4 fragColor;void main() {\nvec2 uv = vTextureCoord;\nvec4 color = getColor(uv);\nif(0 == 2) {\nfragColor = color;} else {\nfragColor = color;\n}\n}","#version 300 es\nprecision highp float;\nprecision highp int;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uTexture;uniform vec2 uMousePos;uvec2 pcg2d(uvec2 v) {\nv = v * 1664525u + 1013904223u;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nv ^= v >> 16;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nreturn v;\n}float randFibo(vec2 p) {\nuvec2 v = floatBitsToUint(p);\nv = pcg2d(v);\nuint r = v.x ^ v.y;\nreturn float(r) / float(0xffffffffu);\n}const float MAX_ITERATIONS = 64.;\nconst float PI2 = 6.28318530718;\nconst float EPSILON = 0.0001;\nconst float stepFactor = 0.0098;vec4 godRays(vec2 st, float decay) {\nvec3 color = vec3(0);\nfloat offset = (0.25 + min(1., 0.7400)) * stepFactor;\nvec2 pos = vec2(0.5197628458498024, 0.5138339920948616) - mix(vec2(0), (vec2(1. - uMousePos.x, 1. - uMousePos.y) - 0.5), 0.5200);\nfloat weight = 1.0;\nfloat bnoz = randFibo(st) * 0.7400;\nfloat distanceInfo = 0.0;\nvec2 marchPos = st;for (float i = 0.0; i < MAX_ITERATIONS; i += 4.0) {\nfor (float j = 0.0; j < 4.0; j++) {\nfloat bno = randFibo(st + vec2(i/MAX_ITERATIONS + j/4.0)) * 0.7400;\nvec2 offbno = vec2(cos(bno) - 0.5, sin(bno) - 0.5);\nfloat x = min(0.999, (i + j) * offset) + bnoz * 0.02;\nfloat y = min(0.999, (i + j));\nmarchPos = st * (1.0 - x) + vec2(x * 0.5) + (pos - 0.5) * x + offbno * 0.02 * 6.5100 * x;\ncolor += texture(uTexture, marchPos).rgb * weight;\ndistanceInfo += y * weight;\nweight *= decay;\nif(weight < 0.01) break;\n}\n}\nreturn vec4(color / MAX_ITERATIONS, distance(st, marchPos));\n}vec4 getGodRays(vec2 uv) {\nif(1.0000 == 0.) {\nreturn vec4(0);\n}\nvec4 rays = godRays(uv, 0.972);\nrays.rgb *= vec3(0.25882352941176473, 0.24313725490196078, 0.30196078431372547);\nvec4 color;\ncolor.rgb = rays.rgb;\ncolor.a = rays.a;\nreturn color;\n}vec4 getColor(vec2 uv) {\nreturn getGodRays(uv);\n}out vec4 fragColor;void main() {\nvec2 uv = vTextureCoord;\nvec4 color = getColor(uv);\nif(1 == 2) {\nfragColor = color;} else {\nfragColor = color;\n}\n}","#version 300 es\nprecision highp float;\nprecision highp int;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uTexture;\nuniform sampler2D uBgTexture;\nuniform sampler2D uBlueNoise;uniform vec2 uResolution;const float MAX_ITERATIONS = 64.;\nconst float PI2 = 6.28318530718;\nconst float EPSILON = 0.0001;\nconst float stepFactor = 0.0098;float luma(vec4 color) {\nreturn dot(color.rgb, vec3(0.299, 0.587, 0.114));\n}float getBlueNoiseOffset(vec2 st) {\nivec2 texSize = ivec2(512, 512);\nvec4 blueNoise = texelFetch(uBlueNoise, ivec2(fract(st * (uResolution)/vec2(texSize) * vec2(texSize.x/texSize.y, 1.0)) * vec2(texSize)) % texSize, 0);\nreturn mod((blueNoise.r - 0.5) * PI2, PI2);\n}vec4 composite(vec2 uv) {\nvec4 godrays = texture(uTexture, uv);\nfloat distanceInfo = godrays.a;\nfloat luminance = luma(godrays);\nfloat blueNoise = getBlueNoiseOffset(uv) - 0.5;\nvec2 circNoise = vec2(cos(blueNoise), sin(blueNoise));\nfloat brightnessScale = (1. - (luminance + 0.25));\nvec2 offset = circNoise * 0.05 * pow(brightnessScale, 3.) * distanceInfo * 2.;\nvec4 color = texture(uTexture, uv + offset);\nvec4 bg = texture(uBgTexture, uv);color.rgb = bg.rgb + (color.rgb * 2.9 * 1.0000 + blueNoise * 0.001);\ncolor.a = bg.a + color.r;\nreturn color;\n}vec4 getColor(vec2 uv) {\nreturn composite(uv);\n}out vec4 fragColor;void main() {\nvec2 uv = vTextureCoord;\nvec4 color = getColor(uv);\nif(2 == 2) {\nfragColor = color;} else {\nfragColor = color;\n}\n}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":false,"passes":[{"prop":"pass","value":1,"downSample":0.5},{"prop":"pass","value":2,"includeBg":true}],"texture":{"src":"https://assets.unicorn.studio/media/blue_noise_med.png","sampler":"uBlueNoise"}},"id":"effect1"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"fog","usesPingPong":false,"speed":0.54,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"animating":true,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;\nprecision highp int;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uTexture;\nuniform float uTime;\nuniform vec2 uMousePos;\nuniform vec2 uResolution;\nfloat ease (int easingFunc, float t) {\nreturn t;\n}\nfloat getExponentialWeight(int index) {\nswitch(index) {\ncase 0: return 1.0000000000;\ncase 1: return 0.7165313106;\ncase 2: return 0.5134171190;\ncase 3: return 0.3678794412;\ncase 4: return 0.2636050919;\ncase 5: return 0.1888756057;\ncase 6: return 0.1353352832;\ncase 7: return 0.0969670595;\ncase 8: return 0.0694877157;\ndefault: return 0.0;\n}\n}out vec4 fragColor;const int kernelSize = 36;\nmat2 rot(float a) {\nreturn mat2(cos(a),-sin(a),sin(a),cos(a));\n}const float PHI = 1.618033988;\nconst float PI = 3.14159265359;float dot_noise(vec3 p) {\nconst mat3 GOLD = mat3(\n-0.571464913, +0.814921382, +0.096597072,\n-0.278044873, -0.303026659, +0.911518454,\n+0.772087367, +0.494042493, +0.399753815);\nreturn dot(cos(GOLD * p), sin(PHI * p * GOLD));\n}float cheap_fbm(vec3 p) {\nmat2 rota = mat2(0.6, -0.8, 0.8, 0.6);\nfloat nos = 0.;\nfloat amp = 1. + 0.8100 * 10.;\nfloat xp = sqrt(2.);\nfloat halfxp = xp * 0.5;\nfor(int i = 0; i < 9; i++) {\nfloat theta = uTime * 0.05 + float(i);\np.xy *= xp;\np.xy += sin(rota * p.xy * xp + theta) * 0.2;\nfloat nz = dot_noise(vec3(p.xy * rota, p.z + theta));\nnos += nz * amp * rota[0][0];\namp *= halfxp;\nrota *= mat2(0.6, -0.8, 0.8, 0.6);\n}\nnos *= 1./float(9);\nfloat density = -3. + 0.5200 * 6.;\nreturn smoothstep(-3., 3., nos + density);\n}float fnoise(vec2 uv) {\nfloat aspectRatio = uResolution.x/uResolution.y;\nvec2 aspect = vec2(aspectRatio, 1);\nfloat multiplier = 10.0 * (0.9700 / ((aspectRatio + 1.) / 2.));\nvec2 st = ((uv * aspect - vec2(0.315450643776824, 0.4605150214592275) * aspect)) * multiplier * rot((0.2484 - 0.125) * 2. * PI);vec2 mPos = vec2(0.315450643776824, 0.4605150214592275) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nvec2 pos = mix(vec2(0.315450643776824, 0.4605150214592275), mPos, floor(1.0000));\nfloat dist = ease(0, max(0.,1.-distance(uv * aspect, mPos * aspect) * 4. * (1. - 1.0000)));if (0 == 1) {\ndist = max(0., (0.5 - dist));\n}\nfloat time = uTime * 0.05;\nvec2 drift = vec2(time * 0.2) * 2.0 * 0.6700;\nfloat fbm = cheap_fbm(vec3(st - drift, time)) * dist;\nfbm = fbm / (1. + fbm);\nreturn fbm;\n}vec4 ExponentialBlur(sampler2D tex, vec2 uv, vec2 direction) {\nvec4 color = vec4(0.0);\nfloat total_weight = 0.0;float fogNoise = fnoise(uv);\nfloat radius = 8.0 * fogNoise * max(0.4200, 0.1);\nradius = mix(0.01, 0.03, radius);vec2 dir = normalize(direction) / vec2(uResolution.x/uResolution.y, 1);vec4 center = texture(tex, uv);\nfloat center_weight = getExponentialWeight(0);\ncolor += center * center_weight;\ntotal_weight += center_weight;for (int i = 1; i <= 8; i++) {\nfloat weight = getExponentialWeight(i);\nfloat offset = radius * float(i) / 8.0;\nvec4 sample1 = texture(tex, uv + offset * dir);\nvec4 sample2 = texture(tex, uv - offset * dir);\ncolor += (sample1 + sample2) * weight;\ntotal_weight += 2.0 * weight;\n}\nfloat scatter = radius * 2.;\ncolor += (\ntexture(tex, uv + scatter * dir) +\ntexture(tex, uv - scatter * dir)\n) * 0.0694877157;return color / total_weight;\n}vec4 blur(vec2 uv, vec2 direction) {\nreturn ExponentialBlur(uTexture, uv, direction);\n}vec4 getColor(vec2 uv) {\nreturn blur(uv, vec2(1, 0));\n}void main() {\nvec2 uv = vTextureCoord;\nvec4 color = getColor(uv);\nfragColor = color;}","#version 300 es\nprecision highp float;\nprecision highp int;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uTexture;\nuniform float uTime;\nuniform vec2 uMousePos;\nuniform vec2 uResolution;\nfloat ease (int easingFunc, float t) {\nreturn t;\n}\nfloat getExponentialWeight(int index) {\nswitch(index) {\ncase 0: return 1.0000000000;\ncase 1: return 0.7165313106;\ncase 2: return 0.5134171190;\ncase 3: return 0.3678794412;\ncase 4: return 0.2636050919;\ncase 5: return 0.1888756057;\ncase 6: return 0.1353352832;\ncase 7: return 0.0969670595;\ncase 8: return 0.0694877157;\ndefault: return 0.0;\n}\n}out vec4 fragColor;const int kernelSize = 36;\nmat2 rot(float a) {\nreturn mat2(cos(a),-sin(a),sin(a),cos(a));\n}const float PHI = 1.618033988;\nconst float PI = 3.14159265359;float dot_noise(vec3 p) {\nconst mat3 GOLD = mat3(\n-0.571464913, +0.814921382, +0.096597072,\n-0.278044873, -0.303026659, +0.911518454,\n+0.772087367, +0.494042493, +0.399753815);\nreturn dot(cos(GOLD * p), sin(PHI * p * GOLD));\n}float cheap_fbm(vec3 p) {\nmat2 rota = mat2(0.6, -0.8, 0.8, 0.6);\nfloat nos = 0.;\nfloat amp = 1. + 0.8100 * 10.;\nfloat xp = sqrt(2.);\nfloat halfxp = xp * 0.5;\nfor(int i = 0; i < 9; i++) {\nfloat theta = uTime * 0.05 + float(i);\np.xy *= xp;\np.xy += sin(rota * p.xy * xp + theta) * 0.2;\nfloat nz = dot_noise(vec3(p.xy * rota, p.z + theta));\nnos += nz * amp * rota[0][0];\namp *= halfxp;\nrota *= mat2(0.6, -0.8, 0.8, 0.6);\n}\nnos *= 1./float(9);\nfloat density = -3. + 0.5200 * 6.;\nreturn smoothstep(-3., 3., nos + density);\n}float fnoise(vec2 uv) {\nfloat aspectRatio = uResolution.x/uResolution.y;\nvec2 aspect = vec2(aspectRatio, 1);\nfloat multiplier = 10.0 * (0.9700 / ((aspectRatio + 1.) / 2.));\nvec2 st = ((uv * aspect - vec2(0.315450643776824, 0.4605150214592275) * aspect)) * multiplier * rot((0.2484 - 0.125) * 2. * PI);vec2 mPos = vec2(0.315450643776824, 0.4605150214592275) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nvec2 pos = mix(vec2(0.315450643776824, 0.4605150214592275), mPos, floor(1.0000));\nfloat dist = ease(0, max(0.,1.-distance(uv * aspect, mPos * aspect) * 4. * (1. - 1.0000)));if (0 == 1) {\ndist = max(0., (0.5 - dist));\n}\nfloat time = uTime * 0.05;\nvec2 drift = vec2(time * 0.2) * 2.0 * 0.6700;\nfloat fbm = cheap_fbm(vec3(st - drift, time)) * dist;\nfbm = fbm / (1. + fbm);\nreturn fbm;\n}vec4 ExponentialBlur(sampler2D tex, vec2 uv, vec2 direction) {\nvec4 color = vec4(0.0);\nfloat total_weight = 0.0;float fogNoise = fnoise(uv);\nfloat radius = 8.0 * fogNoise * max(0.4200, 0.1);\nradius = mix(0.01, 0.03, radius);vec2 dir = normalize(direction) / vec2(uResolution.x/uResolution.y, 1);vec4 center = texture(tex, uv);\nfloat center_weight = getExponentialWeight(0);\ncolor += center * center_weight;\ntotal_weight += center_weight;for (int i = 1; i <= 8; i++) {\nfloat weight = getExponentialWeight(i);\nfloat offset = radius * float(i) / 8.0;\nvec4 sample1 = texture(tex, uv + offset * dir);\nvec4 sample2 = texture(tex, uv - offset * dir);\ncolor += (sample1 + sample2) * weight;\ntotal_weight += 2.0 * weight;\n}\nfloat scatter = radius * 2.;\ncolor += (\ntexture(tex, uv + scatter * dir) +\ntexture(tex, uv - scatter * dir)\n) * 0.0694877157;return color / total_weight;\n}vec4 blur(vec2 uv, vec2 direction) {\nreturn ExponentialBlur(uTexture, uv, direction);\n}vec4 getColor(vec2 uv) {\nreturn blur(uv, vec2(0, 1));\n}void main() {\nvec2 uv = vTextureCoord;\nvec4 color = getColor(uv);\nfragColor = color;}","#version 300 es\nprecision highp float;\nprecision highp int;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uTexture;\nuniform float uTime;\nuniform vec2 uMousePos;\nuniform vec2 uResolution;\nfloat ease (int easingFunc, float t) {\nreturn t;\n}\nfloat getExponentialWeight(int index) {\nswitch(index) {\ncase 0: return 1.0000000000;\ncase 1: return 0.7165313106;\ncase 2: return 0.5134171190;\ncase 3: return 0.3678794412;\ncase 4: return 0.2636050919;\ncase 5: return 0.1888756057;\ncase 6: return 0.1353352832;\ncase 7: return 0.0969670595;\ncase 8: return 0.0694877157;\ndefault: return 0.0;\n}\n}out vec4 fragColor;const int kernelSize = 36;\nmat2 rot(float a) {\nreturn mat2(cos(a),-sin(a),sin(a),cos(a));\n}const float PHI = 1.618033988;\nconst float PI = 3.14159265359;float dot_noise(vec3 p) {\nconst mat3 GOLD = mat3(\n-0.571464913, +0.814921382, +0.096597072,\n-0.278044873, -0.303026659, +0.911518454,\n+0.772087367, +0.494042493, +0.399753815);\nreturn dot(cos(GOLD * p), sin(PHI * p * GOLD));\n}float cheap_fbm(vec3 p) {\nmat2 rota = mat2(0.6, -0.8, 0.8, 0.6);\nfloat nos = 0.;\nfloat amp = 1. + 0.8100 * 10.;\nfloat xp = sqrt(2.);\nfloat halfxp = xp * 0.5;\nfor(int i = 0; i < 9; i++) {\nfloat theta = uTime * 0.05 + float(i);\np.xy *= xp;\np.xy += sin(rota * p.xy * xp + theta) * 0.2;\nfloat nz = dot_noise(vec3(p.xy * rota, p.z + theta));\nnos += nz * amp * rota[0][0];\namp *= halfxp;\nrota *= mat2(0.6, -0.8, 0.8, 0.6);\n}\nnos *= 1./float(9);\nfloat density = -3. + 0.5200 * 6.;\nreturn smoothstep(-3., 3., nos + density);\n}float fnoise(vec2 uv) {\nfloat aspectRatio = uResolution.x/uResolution.y;\nvec2 aspect = vec2(aspectRatio, 1);\nfloat multiplier = 10.0 * (0.9700 / ((aspectRatio + 1.) / 2.));\nvec2 st = ((uv * aspect - vec2(0.315450643776824, 0.4605150214592275) * aspect)) * multiplier * rot((0.2484 - 0.125) * 2. * PI);vec2 mPos = vec2(0.315450643776824, 0.4605150214592275) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nvec2 pos = mix(vec2(0.315450643776824, 0.4605150214592275), mPos, floor(1.0000));\nfloat dist = ease(0, max(0.,1.-distance(uv * aspect, mPos * aspect) * 4. * (1. - 1.0000)));if (0 == 1) {\ndist = max(0., (0.5 - dist));\n}\nfloat time = uTime * 0.05;\nvec2 drift = vec2(time * 0.2) * 2.0 * 0.6700;\nfloat fbm = cheap_fbm(vec3(st - drift, time)) * dist;\nfbm = fbm / (1. + fbm);\nreturn fbm;\n}vec4 ExponentialBlur(sampler2D tex, vec2 uv, vec2 direction) {\nvec4 color = vec4(0.0);\nfloat total_weight = 0.0;float fogNoise = fnoise(uv);\nfloat radius = 8.0 * fogNoise * max(0.4200, 0.1);\nradius = mix(0.01, 0.03, radius);vec2 dir = normalize(direction) / vec2(uResolution.x/uResolution.y, 1);vec4 center = texture(tex, uv);\nfloat center_weight = getExponentialWeight(0);\ncolor += center * center_weight;\ntotal_weight += center_weight;for (int i = 1; i <= 8; i++) {\nfloat weight = getExponentialWeight(i);\nfloat offset = radius * float(i) / 8.0;\nvec4 sample1 = texture(tex, uv + offset * dir);\nvec4 sample2 = texture(tex, uv - offset * dir);\ncolor += (sample1 + sample2) * weight;\ntotal_weight += 2.0 * weight;\n}\nfloat scatter = radius * 2.;\ncolor += (\ntexture(tex, uv + scatter * dir) +\ntexture(tex, uv - scatter * dir)\n) * 0.0694877157;return color / total_weight;\n}vec4 blur(vec2 uv, vec2 direction) {\nreturn ExponentialBlur(uTexture, uv, direction);\n}vec4 getColor(vec2 uv) {\nreturn blur(uv, vec2(1, 1));\n}void main() {\nvec2 uv = vTextureCoord;\nvec4 color = getColor(uv);\nfragColor = color;}","#version 300 es\nprecision highp float;\nprecision highp int;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uTexture;\nuniform float uTime;\nuniform vec2 uMousePos;\nuniform vec2 uResolution;\nfloat ease (int easingFunc, float t) {\nreturn t;\n}\nfloat getExponentialWeight(int index) {\nswitch(index) {\ncase 0: return 1.0000000000;\ncase 1: return 0.7165313106;\ncase 2: return 0.5134171190;\ncase 3: return 0.3678794412;\ncase 4: return 0.2636050919;\ncase 5: return 0.1888756057;\ncase 6: return 0.1353352832;\ncase 7: return 0.0969670595;\ncase 8: return 0.0694877157;\ndefault: return 0.0;\n}\n}out vec4 fragColor;const int kernelSize = 36;\nmat2 rot(float a) {\nreturn mat2(cos(a),-sin(a),sin(a),cos(a));\n}const float PHI = 1.618033988;\nconst float PI = 3.14159265359;float dot_noise(vec3 p) {\nconst mat3 GOLD = mat3(\n-0.571464913, +0.814921382, +0.096597072,\n-0.278044873, -0.303026659, +0.911518454,\n+0.772087367, +0.494042493, +0.399753815);\nreturn dot(cos(GOLD * p), sin(PHI * p * GOLD));\n}float cheap_fbm(vec3 p) {\nmat2 rota = mat2(0.6, -0.8, 0.8, 0.6);\nfloat nos = 0.;\nfloat amp = 1. + 0.8100 * 10.;\nfloat xp = sqrt(2.);\nfloat halfxp = xp * 0.5;\nfor(int i = 0; i < 9; i++) {\nfloat theta = uTime * 0.05 + float(i);\np.xy *= xp;\np.xy += sin(rota * p.xy * xp + theta) * 0.2;\nfloat nz = dot_noise(vec3(p.xy * rota, p.z + theta));\nnos += nz * amp * rota[0][0];\namp *= halfxp;\nrota *= mat2(0.6, -0.8, 0.8, 0.6);\n}\nnos *= 1./float(9);\nfloat density = -3. + 0.5200 * 6.;\nreturn smoothstep(-3., 3., nos + density);\n}float fnoise(vec2 uv) {\nfloat aspectRatio = uResolution.x/uResolution.y;\nvec2 aspect = vec2(aspectRatio, 1);\nfloat multiplier = 10.0 * (0.9700 / ((aspectRatio + 1.) / 2.));\nvec2 st = ((uv * aspect - vec2(0.315450643776824, 0.4605150214592275) * aspect)) * multiplier * rot((0.2484 - 0.125) * 2. * PI);vec2 mPos = vec2(0.315450643776824, 0.4605150214592275) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nvec2 pos = mix(vec2(0.315450643776824, 0.4605150214592275), mPos, floor(1.0000));\nfloat dist = ease(0, max(0.,1.-distance(uv * aspect, mPos * aspect) * 4. * (1. - 1.0000)));if (0 == 1) {\ndist = max(0., (0.5 - dist));\n}\nfloat time = uTime * 0.05;\nvec2 drift = vec2(time * 0.2) * 2.0 * 0.6700;\nfloat fbm = cheap_fbm(vec3(st - drift, time)) * dist;\nfbm = fbm / (1. + fbm);\nreturn fbm;\n}vec4 ExponentialBlur(sampler2D tex, vec2 uv, vec2 direction) {\nvec4 color = vec4(0.0);\nfloat total_weight = 0.0;float fogNoise = fnoise(uv);\nfloat radius = 8.0 * fogNoise * max(0.4200, 0.1);\nradius = mix(0.01, 0.03, radius);vec2 dir = normalize(direction) / vec2(uResolution.x/uResolution.y, 1);vec4 center = texture(tex, uv);\nfloat center_weight = getExponentialWeight(0);\ncolor += center * center_weight;\ntotal_weight += center_weight;for (int i = 1; i <= 8; i++) {\nfloat weight = getExponentialWeight(i);\nfloat offset = radius * float(i) / 8.0;\nvec4 sample1 = texture(tex, uv + offset * dir);\nvec4 sample2 = texture(tex, uv - offset * dir);\ncolor += (sample1 + sample2) * weight;\ntotal_weight += 2.0 * weight;\n}\nfloat scatter = radius * 2.;\ncolor += (\ntexture(tex, uv + scatter * dir) +\ntexture(tex, uv - scatter * dir)\n) * 0.0694877157;return color / total_weight;\n}vec4 blur(vec2 uv, vec2 direction) {\nreturn ExponentialBlur(uTexture, uv, direction);\n}vec4 getColor(vec2 uv) {\nreturn blur(uv, vec2(1, -1));\n}void main() {\nvec2 uv = vTextureCoord;\nvec4 color = getColor(uv);\nfragColor = color;}","#version 300 es\nprecision highp float;\nprecision highp int;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uTexture;\nuniform sampler2D uBgTexture;\nuniform float uTime;\nuniform vec2 uMousePos;\nuniform vec2 uResolution;\nfloat ease (int easingFunc, float t) {\nreturn t;\n}\nuvec2 pcg2d(uvec2 v) {\nv = v * 1664525u + 1013904223u;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nv ^= v >> 16;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nreturn v;\n}float randFibo(vec2 p) {\nuvec2 v = floatBitsToUint(p);\nv = pcg2d(v);\nuint r = v.x ^ v.y;\nreturn float(r) / float(0xffffffffu);\n}vec3 blend (int blendMode, vec3 src, vec3 dst) {\nreturn src + dst;\n}out vec4 fragColor;const int kernelSize = 36;\nmat2 rot(float a) {\nreturn mat2(cos(a),-sin(a),sin(a),cos(a));\n}vec3 Tonemap_ACES(vec3 x) {\nconst float a = 2.51;\nconst float b = 0.03;\nconst float c = 2.43;\nconst float d = 0.59;\nconst float e = 0.14;\nreturn (x * (a * x + b)) / (x * (c * x + d) + e);\n}vec3 chromatic_aberration(vec3 color, vec2 uv, float amount) {\nvec2 offset = normalize(vTextureCoord - 0.5) * amount / vec2(uResolution.x/uResolution.y, 1);\nvec4 left = texture(uTexture, uv - offset);\nvec4 right = texture(uTexture, uv + offset);color.r = left.r;\ncolor.b = right.b;return color;\n}const float PHI = 1.618033988;\nconst float PI = 3.14159265359;float dot_noise(vec3 p) {\nconst mat3 GOLD = mat3(\n-0.571464913, +0.814921382, +0.096597072,\n-0.278044873, -0.303026659, +0.911518454,\n+0.772087367, +0.494042493, +0.399753815);\nreturn dot(cos(GOLD * p), sin(PHI * p * GOLD));\n}float cheap_fbm(vec3 p) {\nmat2 rota = mat2(0.6, -0.8, 0.8, 0.6);\nfloat nos = 0.;\nfloat amp = 1. + 0.8100 * 10.;\nfloat xp = sqrt(2.);\nfloat halfxp = xp * 0.5;\nfor(int i = 0; i < 9; i++) {\nfloat theta = uTime * 0.05 + float(i);\np.xy *= xp;\np.xy += sin(rota * p.xy * xp + theta) * 0.2;\nfloat nz = dot_noise(vec3(p.xy * rota, p.z + theta));\nnos += nz * amp * rota[0][0];\namp *= halfxp;\nrota *= mat2(0.6, -0.8, 0.8, 0.6);\n}\nnos *= 1./float(9);\nfloat density = -3. + 0.5200 * 6.;\nreturn smoothstep(-3., 3., nos + density);\n}float fnoise(vec2 uv) {\nfloat aspectRatio = uResolution.x/uResolution.y;\nvec2 aspect = vec2(aspectRatio, 1);\nfloat multiplier = 10.0 * (0.9700 / ((aspectRatio + 1.) / 2.));\nvec2 st = ((uv * aspect - vec2(0.315450643776824, 0.4605150214592275) * aspect)) * multiplier * rot((0.2484 - 0.125) * 2. * PI);vec2 mPos = vec2(0.315450643776824, 0.4605150214592275) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nvec2 pos = mix(vec2(0.315450643776824, 0.4605150214592275), mPos, floor(1.0000));\nfloat dist = ease(0, max(0.,1.-distance(uv * aspect, mPos * aspect) * 4. * (1. - 1.0000)));if (0 == 1) {\ndist = max(0., (0.5 - dist));\n}\nfloat time = uTime * 0.05;\nvec2 drift = vec2(time * 0.2) * 2.0 * 0.6700;\nfloat fbm = cheap_fbm(vec3(st - drift, time)) * dist;\nfbm = fbm / (1. + fbm);\nreturn fbm;\n}vec4 fogComposite(vec2 uv) {\nvec4 bg = texture(uBgTexture, uv);\nvec4 blur = texture(uTexture, uv);\nfloat aspectRatio = uResolution.x/uResolution.y;\nfloat fogNoise = fnoise(uv);\nfloat fogMask = clamp(fogNoise * 2., 0., 1.);vec3 grain = vec3(randFibo(uv + fogNoise));blur.rgb = chromatic_aberration(blur.rgb, uv, fogMask * 0.01 * 0.4200 * (0.2900 * 2.5));\nblur.rgb = Tonemap_ACES(blur.rgb * (1.2700 + 0.5)) + grain * 0.05;\nvec4 foggedBlur = vec4(blur.rgb * vec3(0.0196078431372549, 0.11372549019607843, 0.19215686274509805), blur.a);\nfoggedBlur.rgb += (0.0000 * 0.25 * fogMask * vec3(0.0196078431372549, 0.11372549019607843, 0.19215686274509805));\nfoggedBlur.rgb = blend(1, bg.rgb, foggedBlur.rgb * fogMask);\nreturn foggedBlur;\n}vec4 getColor(vec2 uv) {\nreturn fogComposite(uv);\n}void main() {\nvec2 uv = vTextureCoord;\nvec4 color = getColor(uv);\nfragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"downSample":0.25,"depth":false,"uniforms":{},"isBackground":false,"passes":[{"prop":"pass","value":1,"downSample":0.25},{"prop":"pass","value":2,"downSample":0.25},{"prop":"pass","value":3,"downSample":0.25},{"prop":"pass","value":4,"includeBg":true}]},"id":"effect2"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"glyphDither","usesPingPong":false,"texture":{"src":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAUAAAAAoCAYAAACPQCMpAAAPhElEQVR4AeydBZAdNwxAtWVuytymzG3aKU4paac05SlzyszMSZmZmTHMzAwTZmZm5t7TVDeb5O7/f/mxb/vXN6e11+td68teWZIl7wYisipAoEEYA2EMpHEMwACLfnf4DxQIFAgUSB8FAgNMX5+HXxwoECjwHwVSzQD/o0FIAgUCBVJKgcAAU9rx4WcHCgQKiBQ8A9xiiy3kuuuuk/fff1+aNWsmLVq0kHfeeUcuvfRS2WyzzRIxBrbZZhu58cYb5c8//5TWrVvL559/rvglArkiJE4++WR58cUXpUmTJtK0aVOpVq2anHLKKUVXkvVPX1955ZWywQbJHtYbb7yx3HbbbfLVV18pPVu2bCnPPvus7L333skiaAqwSfZIyaMDttpqK/n+++9lzpw58ttvv8kjjzwiZ599tpx11lny+OOPS+3atWXWrFly66235tFK/re+++67iuPPP/8sV199tVSuXFnuuecexW/y5Mly3nnn5d9ISU/IoeyQQw6RMWPGSKdOnaR69epy7rnnyjnnnCMvvfSSdOjQQSZMmCBHHHFEDk9yV2WnnXaSV155RYYOHSrz58+Xv//+W7bbbjt3Debx5G233VZatWolixcvlm+//VbuvPNOpeeZZ54pr732mtL6u+++E9d/b7/9tqxatapMALN2jZc93yd+BckAq1SpIjNmzJBbbrlFNtpoI6XrsmXLZNy4cTJ8+HBZsGCBliEBMuDq1aun574PSKSPPfZYcbPz5s3Tl4AXhMJddtlFGjVqJNdeey2nXgEJZeDAgcVSCfSD4QHkQWb33XeXvn37yn333cepNzjggANUSgaXqVOnyvPPPy8HHnigRFHkDYeyNnT55ZfLlClTpErR2DQJde7cuToe+R3Lly/XR/qYUBAOtLEyHCpWrFiG2vlV9YlfwTHAHXfcUdXcTTbZRHuhV69ess8++wjnqBi8KBCYAQnDodJFF12kUhd5X/Dcc8+pREp7vAhHH320oAoz0DbffHN56KGHBEYTRZFKsD5VTnD48ssvlaEgKWAygH577rmnAOTffPNNWblypdb5+OOPBabEb3ENqOHDhg3T/oIBW3szZ860bKJS1N369etLjRo1ZNNNN1XcGjZsKIcffrggETIeoSn1jjnmGDn11FO1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","sampler":"uCustomTexture"},"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec3 vVertexPosition;\nin vec2 vTextureCoord;\nuniform sampler2D uTexture;\nuniform sampler2D uSprite;\nuniform sampler2D uCustomTexture;uniform vec2 uMousePos;\nuniform vec2 uResolution;\nvec3 blend (int blendMode, vec3 src, vec3 dst) {\nreturn vec3((src.x <= 0.5) ? (dst.x - (1.0 - 2.0 * src.x) * dst.x * (1.0 - dst.x)) : (((src.x > 0.5) && (dst.x <= 0.25)) ? (dst.x + (2.0 * src.x - 1.0) * (4.0 * dst.x * (4.0 * dst.x + 1.0) * (dst.x - 1.0) + 7.0 * dst.x)) : (dst.x + (2.0 * src.x - 1.0) * (sqrt(dst.x) - dst.x))), (src.y <= 0.5) ? (dst.y - (1.0 - 2.0 * src.y) * dst.y * (1.0 - dst.y)) : (((src.y > 0.5) && (dst.y <= 0.25)) ? (dst.y + (2.0 * src.y - 1.0) * (4.0 * dst.y * (4.0 * dst.y + 1.0) * (dst.y - 1.0) + 7.0 * dst.y)) : (dst.y + (2.0 * src.y - 1.0) * (sqrt(dst.y) - dst.y))), (src.z <= 0.5) ? (dst.z - (1.0 - 2.0 * src.z) * dst.z * (1.0 - dst.z)) : (((src.z > 0.5) && (dst.z <= 0.25)) ? (dst.z + (2.0 * src.z - 1.0) * (4.0 * dst.z * (4.0 * dst.z + 1.0) * (dst.z - 1.0) + 7.0 * dst.z)) : (dst.z + (2.0 * src.z - 1.0) * (sqrt(dst.z) - dst.z))));\n}out vec4 fragColor;void main() {\nvec2 uv = vTextureCoord;\nvec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nfloat aspectRatio = uResolution.x / uResolution.y;\nfloat aspectCorrection = mix(aspectRatio, 1./aspectRatio, 0.5);float gridSize = mix(0.05, 0.005, 0.2900);float baseGrid = 1.0 / gridSize;\nvec2 cellSize = vec2(1.0/(baseGrid * aspectRatio), 1.0/baseGrid) * aspectCorrection;\nvec2 offsetUv = uv - pos;\nvec2 cell = floor(offsetUv / cellSize);\nvec2 cellCenter = (cell + 0.5) * cellSize;\nvec2 pixelatedCoord = cellCenter + pos;\nvec4 bg = texture(uTexture, vTextureCoord);\nvec4 color = texture(uTexture, pixelatedCoord);float luminance = dot(color.rgb, vec3(0.2126, 0.7152, 0.0722));\nluminance = mix(luminance, 1.0 - luminance, float(0));\nfloat gamma = pow(mix(0.2, 2.2, 0.4000), 2.2);ivec2 customTextureSize = textureSize(uCustomTexture, 0);\nivec2 spriteTextureSize = textureSize(uSprite, 0);\nfloat selectedWidth = mix(float(spriteTextureSize.x), float(customTextureSize.x), float(6 == 6));\nfloat GLYPH_HEIGHT = mix(float(spriteTextureSize.y), float(customTextureSize.y), float(6 == 6));\nfloat scaleFactor = gridSize / GLYPH_HEIGHT;\nfloat numSprites = max(1.0, selectedWidth / GLYPH_HEIGHT);\nfloat numGlyphRows = 1.0;float spriteIndex = clamp(floor(luminance * numSprites), 0.0, numSprites - 1.0);\nfloat spriteIndexWithGamma = clamp(floor(luminance * numSprites * gamma), 0.0, numSprites - 1.0);\nfloat phaseOffset = floor(0.4900 * numSprites + 0.5);\nspriteIndexWithGamma = mod(spriteIndexWithGamma + phaseOffset, numSprites);\nfloat glyphIndex = 0.0;float normalizedSpriteSizeX = 1.0 / numSprites;\nfloat normalizedSpriteSizeY = 1.0 / numGlyphRows;float spriteX = (spriteIndexWithGamma * normalizedSpriteSizeX);vec2 spriteSheetUV = vec2(spriteX, glyphIndex / numGlyphRows);vec2 spriteSize = vec2(GLYPH_HEIGHT / aspectRatio, GLYPH_HEIGHT) * scaleFactor * aspectCorrection;\nvec2 localOffset = mod(uv - pos, spriteSize) / spriteSize;float inset = 0.5 / GLYPH_HEIGHT;\nlocalOffset = clamp(localOffset, inset, 1.0 - inset);spriteSheetUV += vec2(localOffset.x * normalizedSpriteSizeX, localOffset.y * normalizedSpriteSizeY);vec4 spriteColor = vec4(0.0);spriteColor = texture(uCustomTexture, spriteSheetUV);\nfloat alpha = smoothstep(0.0, 1.0, spriteColor.r);vec3 cc = (color.rgb - spriteIndex * 0.04) * 1.4;\nvec3 col = cc;vec3 dithered = mix(\nmix(vec3(0.0), vec3(1.0), float(0)),\ncol,\nalpha\n);\ncolor.rgb = mix(bg.rgb, dithered, 0.4900);\nvec3 blended = blend(12, dithered, bg.rgb);\ncolor.rgb = mix(bg.rgb, blended, 0.4900);\nfragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":false,"texture":{"src":"","sampler":"uSprite"}},"id":"effect3"},{"breakpoints":[],"visible":true,"locked":false,"aspectRatio":21.428571428571427,"layerName":"","userDownsample":1,"isElement":true,"opacity":1,"effects":[],"displace":0,"trackMouse":0,"anchorPoint":"center","mouseMomentum":0,"blendMode":"NORMAL","bgDisplace":0,"mask":0,"maskBackground":{"type":"Vec3","_x":0,"_y":0,"_z":0},"maskAlpha":0,"maskDepth":0,"dispersion":0,"axisTilt":0,"states":{"appear":[],"scroll":[],"hover":[]},"layerType":"image","imageLoaded":false,"width":450,"widthMode":"fixed","height":21,"heightMode":"auto","left":0.5,"leftMode":"relative","top":0.5,"topMode":"relative","rotation":0,"trackAxes":"xy","fitToCanvas":0,"exposure":0,"saturation":1,"contrast":1,"src":"https://assets.unicorn.studio/images/FqmFlgX22DYYksu4G0pmfL7UiNX2/Asset%201_v25.svg","naturalWidth":300,"naturalHeight":14,"compiledFragmentShaders":["#version 300 es\nprecision highp float;\nin vec2 vTextureCoord;\nin vec3 vVertexPosition;uniform vec2 uMousePos;\nuniform sampler2D uBgTexture;\nuniform sampler2D uTexture;\nuniform int uSampleBg;const float STEPS = 24.0;\nconst float PI = 3.1415926;out vec4 fragColor;vec4 getNormalOutput(vec4 color, vec4 background) {\ncolor = mix(background, color + background * (1.0 - color.a), 1.0000);\nreturn color;\n}vec4 getOutputByMode(vec4 color, vec4 background) {\nreturn getNormalOutput(color, background);\n}void main() {\nvec2 uv = vTextureCoord;\nvec2 pos = mix(vec2(0), (uMousePos - 0.5), 0.0000);uv -= pos;vec4 background = vec4(0);\nif(uSampleBg == 1) {\nbackground = texture(uBgTexture, vTextureCoord);\n}\nvec4 color = texture(uTexture, uv);color.rgb = clamp(color.rgb, 0.0, 1.0);vec4 col = getOutputByMode(color, background);fragColor = col;\n}"],"compiledVertexShaders":["#version 300 es\nprecision highp float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;\nuniform vec2 uMousePos;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\nfloat angleX = uMousePos.y * 0.5 - 0.25;\nfloat angleY = (1.-uMousePos.x) * 0.5 - 0.25;mat4 rotateX = mat4(1.0, 0.0, 0.0, 0.0,\n0.0, cos(angleX), -sin(angleX), 0.0,\n0.0, sin(angleX), cos(angleX), 0.0,\n0.0, 0.0, 0.0, 1.0);\nmat4 rotateY = mat4(cos(angleY), 0.0, sin(angleY), 0.0,\n0.0, 1.0, 0.0, 0.0,\n-sin(angleY), 0.0, cos(angleY), 0.0,\n0.0, 0.0, 0.0, 1.0);mat4 rotationMatrix = rotateX * rotateY;\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvVertexPosition = (rotationMatrix * vec4(aVertexPosition, 1.0)).xyz;\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"uniforms":{}},"id":"image1"}],"options":{"name":"Copy of Glow (3)","fps":60,"dpi":1.5,"scale":1,"includeLogo":false,"isProduction":false},"version":"1.5.2","id":"fudFhOk7dhZ9Do6Skkkr","modules":{"model_renderer":{"type":"cdn-import","url":"https://cdn.jsdelivr.net/gh/hiunicornstudio/unicornstudio.js@v1.5.2/extensions/model-renderer.js","version":"v1.5.2"}}}